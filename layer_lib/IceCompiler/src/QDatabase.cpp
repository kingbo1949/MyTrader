//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `QDatabase.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <QDatabase.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_IBTrader_IQDatabase_ids[2] =
{
    "::IBTrader::IQDatabase",
    "::Ice::Object"
};
const ::std::string iceC_IBTrader_IQDatabase_ops[] =
{
    "DelCodeId",
    "GetAtrs",
    "GetDivTypes",
    "GetEmas",
    "GetInvalidKLines",
    "GetKLinePairs",
    "GetKLines",
    "GetLastUpdateTick",
    "GetMacds",
    "GetMas",
    "GetOneAtr",
    "GetOneDivType",
    "GetOneEma",
    "GetOneKLine",
    "GetOneMa",
    "GetOneMacd",
    "GetOneTick",
    "GetOneVwMa",
    "GetTicks",
    "GetVwMas",
    "IdlCount",
    "IsAllIdle",
    "RecountAllIndex",
    "RemoveAllKLines",
    "RemoveAllTicks",
    "RemoveKLinesByRange",
    "RemoveOneKLine",
    "RemoveTicksByRange",
    "TaskCount",
    "UpdateAllIndexFromTimePos",
    "UpdateKLine",
    "UpdateKLines",
    "UpdateTickToDB",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_IBTrader_IQDatabase_IdlCount_name = "IdlCount";
const ::std::string iceC_IBTrader_IQDatabase_IsAllIdle_name = "IsAllIdle";
const ::std::string iceC_IBTrader_IQDatabase_TaskCount_name = "TaskCount";
const ::std::string iceC_IBTrader_IQDatabase_UpdateTickToDB_name = "UpdateTickToDB";
const ::std::string iceC_IBTrader_IQDatabase_GetLastUpdateTick_name = "GetLastUpdateTick";
const ::std::string iceC_IBTrader_IQDatabase_DelCodeId_name = "DelCodeId";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllTicks_name = "RemoveAllTicks";
const ::std::string iceC_IBTrader_IQDatabase_RemoveTicksByRange_name = "RemoveTicksByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetTicks_name = "GetTicks";
const ::std::string iceC_IBTrader_IQDatabase_GetOneTick_name = "GetOneTick";
const ::std::string iceC_IBTrader_IQDatabase_UpdateKLine_name = "UpdateKLine";
const ::std::string iceC_IBTrader_IQDatabase_UpdateKLines_name = "UpdateKLines";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllKLines_name = "RemoveAllKLines";
const ::std::string iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name = "RemoveKLinesByRange";
const ::std::string iceC_IBTrader_IQDatabase_RemoveOneKLine_name = "RemoveOneKLine";
const ::std::string iceC_IBTrader_IQDatabase_GetKLines_name = "GetKLines";
const ::std::string iceC_IBTrader_IQDatabase_GetOneKLine_name = "GetOneKLine";
const ::std::string iceC_IBTrader_IQDatabase_GetKLinePairs_name = "GetKLinePairs";
const ::std::string iceC_IBTrader_IQDatabase_GetInvalidKLines_name = "GetInvalidKLines";
const ::std::string iceC_IBTrader_IQDatabase_RecountAllIndex_name = "RecountAllIndex";
const ::std::string iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name = "UpdateAllIndexFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_GetMas_name = "GetMas";
const ::std::string iceC_IBTrader_IQDatabase_GetOneMa_name = "GetOneMa";
const ::std::string iceC_IBTrader_IQDatabase_GetVwMas_name = "GetVwMas";
const ::std::string iceC_IBTrader_IQDatabase_GetOneVwMa_name = "GetOneVwMa";
const ::std::string iceC_IBTrader_IQDatabase_GetEmas_name = "GetEmas";
const ::std::string iceC_IBTrader_IQDatabase_GetOneEma_name = "GetOneEma";
const ::std::string iceC_IBTrader_IQDatabase_GetMacds_name = "GetMacds";
const ::std::string iceC_IBTrader_IQDatabase_GetOneMacd_name = "GetOneMacd";
const ::std::string iceC_IBTrader_IQDatabase_GetDivTypes_name = "GetDivTypes";
const ::std::string iceC_IBTrader_IQDatabase_GetOneDivType_name = "GetOneDivType";
const ::std::string iceC_IBTrader_IQDatabase_GetAtrs_name = "GetAtrs";
const ::std::string iceC_IBTrader_IQDatabase_GetOneAtr_name = "GetOneAtr";

}

bool
IBTrader::IQDatabase::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IBTrader_IQDatabase_ids, iceC_IBTrader_IQDatabase_ids + 2, s);
}

::std::vector<::std::string>
IBTrader::IQDatabase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IBTrader_IQDatabase_ids[0], &iceC_IBTrader_IQDatabase_ids[2]);
}

::std::string
IBTrader::IQDatabase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IBTrader::IQDatabase::ice_staticId()
{
    static const ::std::string typeId = "::IBTrader::IQDatabase";
    return typeId;
}

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_IdlCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int ret = this->IdlCount(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_IsAllIdle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->IsAllIdle(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_TaskCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int ret = this->TaskCount(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateTickToDB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ITick iceP_tick;
    istr->readAll(iceP_tick);
    inS.endReadParams();
    this->UpdateTickToDB(::std::move(iceP_tick), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetLastUpdateTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int iceP_updateCount;
    long long int iceP_recentUpdateSecnd;
    ITick ret = this->GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_updateCount, iceP_recentUpdateSecnd, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_DelCodeId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->DelCodeId(::std::move(iceP_codeId), iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    istr->readAll(iceP_codeId);
    inS.endReadParams();
    this->RemoveAllTicks(::std::move(iceP_codeId), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveTicksByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveTicksByRange(::std::move(iceP_codeId), iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_query);
    inS.endReadParams();
    ITicks iceP_ticks;
    this->GetTicks(::std::move(iceP_codeId), ::std::move(iceP_query), iceP_ticks, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ticks);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timePos);
    inS.endReadParams();
    ITick iceP_tick;
    bool ret = this->GetOneTick(::std::move(iceP_codeId), iceP_timePos, iceP_tick, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_tick, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IKLine iceP_kline;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_kline);
    inS.endReadParams();
    this->UpdateKLine(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_kline), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IKLines iceP_klines;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_klines);
    inS.endReadParams();
    this->UpdateKLines(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_klines), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllKLines(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveKLinesByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveKLinesByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RemoveOneKLine(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetKLines(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_klines, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IKLine iceP_kline;
    bool ret = this->GetOneKLine(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_kline, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_kline, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLinePairs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_first;
    ::std::string iceP_second;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_first, iceP_second, iceP_timeType, iceP_query);
    inS.endReadParams();
    IKLinePairs iceP_kLinePairs;
    this->GetKLinePairs(::std::move(iceP_first), ::std::move(iceP_second), iceP_timeType, ::std::move(iceP_query), iceP_kLinePairs, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_kLinePairs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetInvalidKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetInvalidKLines(::std::move(iceP_codeId), iceP_timeType, iceP_klines, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountAllIndex(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountAllIndex(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateAllIndexFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->UpdateAllIndexFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetMas(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_mas, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneMa(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ma, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ma, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetVwMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetVwMas(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_mas, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneVwMa(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ma, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ma, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetEmas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgValues iceP_emas;
    this->GetEmas(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_emas, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_emas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ema;
    bool ret = this->GetOneEma(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ema, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ema, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMacds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IMacdValues iceP_macds;
    this->GetMacds(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_macds, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_macds);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IMacdValue iceP_ma;
    bool ret = this->GetOneMacd(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ma, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ma, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetDivTypes(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IDivTypeValues iceP_divtypes;
    this->GetDivTypes(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_divtypes, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_divtypes);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IDivTypeValue iceP_divtype;
    bool ret = this->GetOneDivType(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_divtype, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_divtype, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetAtrs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAtrValues iceP_avgAtrs;
    this->GetAtrs(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_avgAtrs, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_avgAtrs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAtrValue iceP_avgAtr;
    bool ret = this->GetOneAtr(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_avgAtr, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_avgAtr, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IBTrader_IQDatabase_ops, iceC_IBTrader_IQDatabase_ops + 37, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IBTrader_IQDatabase_ops)
    {
        case 0:
        {
            return _iceD_DelCodeId(in, current);
        }
        case 1:
        {
            return _iceD_GetAtrs(in, current);
        }
        case 2:
        {
            return _iceD_GetDivTypes(in, current);
        }
        case 3:
        {
            return _iceD_GetEmas(in, current);
        }
        case 4:
        {
            return _iceD_GetInvalidKLines(in, current);
        }
        case 5:
        {
            return _iceD_GetKLinePairs(in, current);
        }
        case 6:
        {
            return _iceD_GetKLines(in, current);
        }
        case 7:
        {
            return _iceD_GetLastUpdateTick(in, current);
        }
        case 8:
        {
            return _iceD_GetMacds(in, current);
        }
        case 9:
        {
            return _iceD_GetMas(in, current);
        }
        case 10:
        {
            return _iceD_GetOneAtr(in, current);
        }
        case 11:
        {
            return _iceD_GetOneDivType(in, current);
        }
        case 12:
        {
            return _iceD_GetOneEma(in, current);
        }
        case 13:
        {
            return _iceD_GetOneKLine(in, current);
        }
        case 14:
        {
            return _iceD_GetOneMa(in, current);
        }
        case 15:
        {
            return _iceD_GetOneMacd(in, current);
        }
        case 16:
        {
            return _iceD_GetOneTick(in, current);
        }
        case 17:
        {
            return _iceD_GetOneVwMa(in, current);
        }
        case 18:
        {
            return _iceD_GetTicks(in, current);
        }
        case 19:
        {
            return _iceD_GetVwMas(in, current);
        }
        case 20:
        {
            return _iceD_IdlCount(in, current);
        }
        case 21:
        {
            return _iceD_IsAllIdle(in, current);
        }
        case 22:
        {
            return _iceD_RecountAllIndex(in, current);
        }
        case 23:
        {
            return _iceD_RemoveAllKLines(in, current);
        }
        case 24:
        {
            return _iceD_RemoveAllTicks(in, current);
        }
        case 25:
        {
            return _iceD_RemoveKLinesByRange(in, current);
        }
        case 26:
        {
            return _iceD_RemoveOneKLine(in, current);
        }
        case 27:
        {
            return _iceD_RemoveTicksByRange(in, current);
        }
        case 28:
        {
            return _iceD_TaskCount(in, current);
        }
        case 29:
        {
            return _iceD_UpdateAllIndexFromTimePos(in, current);
        }
        case 30:
        {
            return _iceD_UpdateKLine(in, current);
        }
        case 31:
        {
            return _iceD_UpdateKLines(in, current);
        }
        case 32:
        {
            return _iceD_UpdateTickToDB(in, current);
        }
        case 33:
        {
            return _iceD_ice_id(in, current);
        }
        case 34:
        {
            return _iceD_ice_ids(in, current);
        }
        case 35:
        {
            return _iceD_ice_isA(in, current);
        }
        case 36:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_IdlCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_IdlCount_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_IdlCount_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_IsAllIdle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_IsAllIdle_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_IsAllIdle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_TaskCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_TaskCount_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_TaskCount_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateTickToDB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ITick& iceP_tick, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateTickToDB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_tick);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetLastUpdateTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetLastUpdateTickResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetLastUpdateTickResult v;
            istr->readAll(v.updateCount, v.recentUpdateSecnd, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_DelCodeId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_DelCodeId_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllTicks_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveTicksByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveTicksByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::ITicks>>& outAsync, const ::std::string& iceP_codeId, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetTicks_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetTicks_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneTickResult>>& outAsync, const ::std::string& iceP_codeId, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneTick_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneTick_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneTickResult v;
            istr->readAll(v.tick, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IKLine& iceP_kline, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateKLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_kline);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IKLines& iceP_klines, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_klines);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveKLinesByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveOneKLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLines_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneKLineResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneKLine_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneKLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneKLineResult v;
            istr->readAll(v.kline, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetKLinePairs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLinePairs>>& outAsync, const ::std::string& iceP_first, const ::std::string& iceP_second, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetKLinePairs_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_first, iceP_second, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetInvalidKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetInvalidKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountAllIndex(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountAllIndex_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateAllIndexFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMas_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetMas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMaResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMa_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneMaResult v;
            istr->readAll(v.ma, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetVwMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetVwMas_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetVwMas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneVwMaResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneVwMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneVwMaResult v;
            istr->readAll(v.ma, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetEmas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetEmas_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetEmas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneEmaResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneEma_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneEma_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneEmaResult v;
            istr->readAll(v.ema, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetMacds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IMacdValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMacds_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetMacds_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMacdResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMacd_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneMacd_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneMacdResult v;
            istr->readAll(v.ma, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetDivTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IDivTypeValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetDivTypes_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetDivTypes_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneDivTypeResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneDivType_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneDivType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneDivTypeResult v;
            istr->readAll(v.divtype, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetAtrs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAtrValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetAtrs_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetAtrs_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneAtrResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneAtr_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneAtr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneAtrResult v;
            istr->readAll(v.avgAtr, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
IBTrader::IQDatabasePrx::_newInstance() const
{
    return ::IceInternal::createProxy<IQDatabasePrx>();
}
/// \endcond

const ::std::string&
IBTrader::IQDatabasePrx::ice_staticId()
{
    return IQDatabase::ice_staticId();
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_IBTrader_IQDatabase_IdlCount_name = "IdlCount";

const ::std::string iceC_IBTrader_IQDatabase_IsAllIdle_name = "IsAllIdle";

const ::std::string iceC_IBTrader_IQDatabase_TaskCount_name = "TaskCount";

const ::std::string iceC_IBTrader_IQDatabase_UpdateTickToDB_name = "UpdateTickToDB";

const ::std::string iceC_IBTrader_IQDatabase_GetLastUpdateTick_name = "GetLastUpdateTick";

const ::std::string iceC_IBTrader_IQDatabase_DelCodeId_name = "DelCodeId";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllTicks_name = "RemoveAllTicks";

const ::std::string iceC_IBTrader_IQDatabase_RemoveTicksByRange_name = "RemoveTicksByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetTicks_name = "GetTicks";

const ::std::string iceC_IBTrader_IQDatabase_GetOneTick_name = "GetOneTick";

const ::std::string iceC_IBTrader_IQDatabase_UpdateKLine_name = "UpdateKLine";

const ::std::string iceC_IBTrader_IQDatabase_UpdateKLines_name = "UpdateKLines";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllKLines_name = "RemoveAllKLines";

const ::std::string iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name = "RemoveKLinesByRange";

const ::std::string iceC_IBTrader_IQDatabase_RemoveOneKLine_name = "RemoveOneKLine";

const ::std::string iceC_IBTrader_IQDatabase_GetKLines_name = "GetKLines";

const ::std::string iceC_IBTrader_IQDatabase_GetOneKLine_name = "GetOneKLine";

const ::std::string iceC_IBTrader_IQDatabase_GetKLinePairs_name = "GetKLinePairs";

const ::std::string iceC_IBTrader_IQDatabase_GetInvalidKLines_name = "GetInvalidKLines";

const ::std::string iceC_IBTrader_IQDatabase_RecountAllIndex_name = "RecountAllIndex";

const ::std::string iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name = "UpdateAllIndexFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_GetMas_name = "GetMas";

const ::std::string iceC_IBTrader_IQDatabase_GetOneMa_name = "GetOneMa";

const ::std::string iceC_IBTrader_IQDatabase_GetVwMas_name = "GetVwMas";

const ::std::string iceC_IBTrader_IQDatabase_GetOneVwMa_name = "GetOneVwMa";

const ::std::string iceC_IBTrader_IQDatabase_GetEmas_name = "GetEmas";

const ::std::string iceC_IBTrader_IQDatabase_GetOneEma_name = "GetOneEma";

const ::std::string iceC_IBTrader_IQDatabase_GetMacds_name = "GetMacds";

const ::std::string iceC_IBTrader_IQDatabase_GetOneMacd_name = "GetOneMacd";

const ::std::string iceC_IBTrader_IQDatabase_GetDivTypes_name = "GetDivTypes";

const ::std::string iceC_IBTrader_IQDatabase_GetOneDivType_name = "GetOneDivType";

const ::std::string iceC_IBTrader_IQDatabase_GetAtrs_name = "GetAtrs";

const ::std::string iceC_IBTrader_IQDatabase_GetOneAtr_name = "GetOneAtr";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::IBTrader::upCast(IQDatabase* p) { return p; }

void
::IceProxy::IBTrader::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< IQDatabase>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new IQDatabase;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_IdlCount(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_IdlCount_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_IdlCount_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_IdlCount_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_IBTrader_IQDatabase_IdlCount_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::IBTrader::IQDatabase::end_IdlCount(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_IdlCount_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_IsAllIdle(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_IsAllIdle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_IsAllIdle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_IsAllIdle_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_IBTrader_IQDatabase_IsAllIdle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_IsAllIdle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_IsAllIdle_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_TaskCount(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_TaskCount_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_TaskCount_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_TaskCount_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_IBTrader_IQDatabase_TaskCount_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::IBTrader::IQDatabase::end_TaskCount(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_TaskCount_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateTickToDB(const ::IBTrader::ITick& iceP_tick, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateTickToDB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateTickToDB_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_tick);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateTickToDB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateTickToDB(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateTickToDB_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetLastUpdateTick(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::IBTrader::ITick
IceProxy::IBTrader::IQDatabase::end_GetLastUpdateTick(::Ice::Int& iceP_updateCount, ::Ice::Long& iceP_recentUpdateSecnd, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    ::IBTrader::ITick ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_updateCount);
    istr->read(iceP_recentUpdateSecnd);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetLastUpdateTick(::Ice::Int& iceP_updateCount, ::Ice::Long& iceP_recentUpdateSecnd, ::IBTrader::ITick& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_updateCount);
    istr->read(iceP_recentUpdateSecnd);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_DelCodeId(const ::std::string& iceP_codeId, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_DelCodeId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_DelCodeId_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_DelCodeId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_DelCodeId(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_DelCodeId_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllTicks(const ::std::string& iceP_codeId, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllTicks_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllTicks_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllTicks_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllTicks(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllTicks_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveTicksByRange(const ::std::string& iceP_codeId, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveTicksByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveTicksByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveTicksByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveTicksByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveTicksByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetTicks(const ::std::string& iceP_codeId, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetTicks_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetTicks_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetTicks_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetTicks_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetTicks(::IBTrader::ITicks& iceP_ticks, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetTicks_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ticks);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetTicks(::IBTrader::ITicks& iceP_ticks, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetTicks_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ticks);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneTick(const ::std::string& iceP_codeId, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneTick_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneTick_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneTick_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneTick_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneTick(::IBTrader::ITick& iceP_tick, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneTick_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_tick);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneTick(::IBTrader::ITick& iceP_tick, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneTick_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_tick);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateKLine(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IKLine& iceP_kline, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateKLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateKLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_kline);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateKLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateKLine(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateKLine_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IKLines& iceP_klines, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_klines);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateKLines(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateKLines_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllKLines(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllKLines_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveKLinesByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveKLinesByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveOneKLine(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveOneKLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveOneKLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveOneKLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveOneKLine(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveOneKLine_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLines_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneKLine(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneKLine_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneKLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneKLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneKLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneKLine(::IBTrader::IKLine& iceP_kline, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneKLine_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kline);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneKLine(::IBTrader::IKLine& iceP_kline, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneKLine_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kline);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetKLinePairs(const ::std::string& iceP_first, const ::std::string& iceP_second, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLinePairs_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetKLinePairs_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetKLinePairs_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_first);
        ostr->write(iceP_second);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetKLinePairs(::IBTrader::IKLinePairs& iceP_kLinePairs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kLinePairs);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetKLinePairs(::IBTrader::IKLinePairs& iceP_kLinePairs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kLinePairs);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetInvalidKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetInvalidKLines_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetInvalidKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetInvalidKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetInvalidKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetInvalidKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountAllIndex(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountAllIndex_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountAllIndex_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountAllIndex_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountAllIndex(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountAllIndex_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateAllIndexFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateAllIndexFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateAllIndexFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetMas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMas_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetMas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetMas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetMas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMa_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneMa(::IBTrader::IAvgValue& iceP_ma, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMa_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMa_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetVwMas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetVwMas_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetVwMas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetVwMas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetVwMas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetVwMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetVwMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetVwMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetVwMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneVwMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneVwMa_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneVwMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneVwMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneVwMa(::IBTrader::IAvgValue& iceP_ma, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneVwMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetEmas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetEmas_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetEmas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetEmas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetEmas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetEmas(::IBTrader::IAvgValues& iceP_emas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetEmas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_emas);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetEmas(::IBTrader::IAvgValues& iceP_emas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetEmas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_emas);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneEma(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneEma_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneEma_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneEma_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneEma_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneEma(::IBTrader::IAvgValue& iceP_ema, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneEma_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ema);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneEma(::IBTrader::IAvgValue& iceP_ema, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneEma_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ema);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetMacds(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMacds_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetMacds_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetMacds_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetMacds_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetMacds(::IBTrader::IMacdValues& iceP_macds, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMacds_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_macds);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetMacds(::IBTrader::IMacdValues& iceP_macds, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMacds_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_macds);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneMacd(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMacd_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneMacd_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneMacd_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneMacd_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneMacd(::IBTrader::IMacdValue& iceP_ma, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMacd_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneMacd(::IBTrader::IMacdValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMacd_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetDivTypes(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetDivTypes_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetDivTypes_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetDivTypes_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetDivTypes_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetDivTypes(::IBTrader::IDivTypeValues& iceP_divtypes, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetDivTypes_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtypes);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetDivTypes(::IBTrader::IDivTypeValues& iceP_divtypes, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetDivTypes_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtypes);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneDivType(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneDivType_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneDivType_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneDivType_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneDivType_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneDivType(::IBTrader::IDivTypeValue& iceP_divtype, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneDivType_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtype);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneDivType(::IBTrader::IDivTypeValue& iceP_divtype, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneDivType_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtype);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetAtrs(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetAtrs_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetAtrs_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetAtrs_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetAtrs_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetAtrs(::IBTrader::IAtrValues& iceP_avgAtrs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetAtrs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtrs);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetAtrs(::IBTrader::IAtrValues& iceP_avgAtrs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetAtrs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtrs);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneAtr(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneAtr_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneAtr_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneAtr_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneAtr_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneAtr(::IBTrader::IAtrValue& iceP_avgAtr, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneAtr_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtr);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneAtr(::IBTrader::IAtrValue& iceP_avgAtr, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneAtr_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtr);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::IBTrader::IQDatabase::_newInstance() const
{
    return new IQDatabase;
}
/// \endcond

const ::std::string&
IceProxy::IBTrader::IQDatabase::ice_staticId()
{
    return ::IBTrader::IQDatabase::ice_staticId();
}

IBTrader::IQDatabase::~IQDatabase()
{
}

/// \cond INTERNAL
::Ice::Object* IBTrader::upCast(IQDatabase* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_IBTrader_IQDatabase_ids[2] =
{
    "::IBTrader::IQDatabase",
    "::Ice::Object"
};

}

bool
IBTrader::IQDatabase::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IBTrader_IQDatabase_ids, iceC_IBTrader_IQDatabase_ids + 2, s);
}

::std::vector< ::std::string>
IBTrader::IQDatabase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_IBTrader_IQDatabase_ids[0], &iceC_IBTrader_IQDatabase_ids[2]);
}

const ::std::string&
IBTrader::IQDatabase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IBTrader::IQDatabase::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::IBTrader::IQDatabase";
    return typeId;
#else
    return iceC_IBTrader_IQDatabase_ids[0];
#endif
}

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_IdlCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int ret = this->IdlCount(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_IsAllIdle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->IsAllIdle(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_TaskCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int ret = this->TaskCount(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateTickToDB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ITick iceP_tick;
    istr->read(iceP_tick);
    inS.endReadParams();
    this->UpdateTickToDB(iceP_tick, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetLastUpdateTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int iceP_updateCount;
    ::Ice::Long iceP_recentUpdateSecnd;
    ITick ret = this->GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_updateCount);
    ostr->write(iceP_recentUpdateSecnd);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_DelCodeId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->DelCodeId(iceP_codeId, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    istr->read(iceP_codeId);
    inS.endReadParams();
    this->RemoveAllTicks(iceP_codeId, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveTicksByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveTicksByRange(iceP_codeId, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_query);
    inS.endReadParams();
    ITicks iceP_ticks;
    this->GetTicks(iceP_codeId, iceP_query, iceP_ticks, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ticks);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timePos);
    inS.endReadParams();
    ITick iceP_tick;
    bool ret = this->GetOneTick(iceP_codeId, iceP_timePos, iceP_tick, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_tick);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IKLine iceP_kline;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_kline);
    inS.endReadParams();
    this->UpdateKLine(iceP_codeId, iceP_timeType, iceP_kline, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IKLines iceP_klines;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_klines);
    inS.endReadParams();
    this->UpdateKLines(iceP_codeId, iceP_timeType, iceP_klines, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllKLines(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveKLinesByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveKLinesByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RemoveOneKLine(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetKLines(iceP_codeId, iceP_timeType, iceP_query, iceP_klines, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IKLine iceP_kline;
    bool ret = this->GetOneKLine(iceP_codeId, iceP_timeType, iceP_timePos, iceP_kline, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_kline);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLinePairs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_first;
    ::std::string iceP_second;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_first);
    istr->read(iceP_second);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IKLinePairs iceP_kLinePairs;
    this->GetKLinePairs(iceP_first, iceP_second, iceP_timeType, iceP_query, iceP_kLinePairs, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_kLinePairs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetInvalidKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetInvalidKLines(iceP_codeId, iceP_timeType, iceP_klines, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountAllIndex(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountAllIndex(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateAllIndexFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->UpdateAllIndexFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetMas(iceP_codeId, iceP_timeType, iceP_query, iceP_mas, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneMa(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ma, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ma);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetVwMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetVwMas(iceP_codeId, iceP_timeType, iceP_query, iceP_mas, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneVwMa(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ma, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ma);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetEmas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgValues iceP_emas;
    this->GetEmas(iceP_codeId, iceP_timeType, iceP_query, iceP_emas, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_emas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ema;
    bool ret = this->GetOneEma(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ema, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ema);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMacds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IMacdValues iceP_macds;
    this->GetMacds(iceP_codeId, iceP_timeType, iceP_query, iceP_macds, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_macds);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IMacdValue iceP_ma;
    bool ret = this->GetOneMacd(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ma, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ma);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetDivTypes(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IDivTypeValues iceP_divtypes;
    this->GetDivTypes(iceP_codeId, iceP_timeType, iceP_query, iceP_divtypes, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_divtypes);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IDivTypeValue iceP_divtype;
    bool ret = this->GetOneDivType(iceP_codeId, iceP_timeType, iceP_timePos, iceP_divtype, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_divtype);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetAtrs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAtrValues iceP_avgAtrs;
    this->GetAtrs(iceP_codeId, iceP_timeType, iceP_query, iceP_avgAtrs, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_avgAtrs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAtrValue iceP_avgAtr;
    bool ret = this->GetOneAtr(iceP_codeId, iceP_timeType, iceP_timePos, iceP_avgAtr, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_avgAtr);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_IBTrader_IQDatabase_all[] =
{
    "DelCodeId",
    "GetAtrs",
    "GetDivTypes",
    "GetEmas",
    "GetInvalidKLines",
    "GetKLinePairs",
    "GetKLines",
    "GetLastUpdateTick",
    "GetMacds",
    "GetMas",
    "GetOneAtr",
    "GetOneDivType",
    "GetOneEma",
    "GetOneKLine",
    "GetOneMa",
    "GetOneMacd",
    "GetOneTick",
    "GetOneVwMa",
    "GetTicks",
    "GetVwMas",
    "IdlCount",
    "IsAllIdle",
    "RecountAllIndex",
    "RemoveAllKLines",
    "RemoveAllTicks",
    "RemoveKLinesByRange",
    "RemoveOneKLine",
    "RemoveTicksByRange",
    "TaskCount",
    "UpdateAllIndexFromTimePos",
    "UpdateKLine",
    "UpdateKLines",
    "UpdateTickToDB",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IBTrader_IQDatabase_all, iceC_IBTrader_IQDatabase_all + 37, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IBTrader_IQDatabase_all)
    {
        case 0:
        {
            return _iceD_DelCodeId(in, current);
        }
        case 1:
        {
            return _iceD_GetAtrs(in, current);
        }
        case 2:
        {
            return _iceD_GetDivTypes(in, current);
        }
        case 3:
        {
            return _iceD_GetEmas(in, current);
        }
        case 4:
        {
            return _iceD_GetInvalidKLines(in, current);
        }
        case 5:
        {
            return _iceD_GetKLinePairs(in, current);
        }
        case 6:
        {
            return _iceD_GetKLines(in, current);
        }
        case 7:
        {
            return _iceD_GetLastUpdateTick(in, current);
        }
        case 8:
        {
            return _iceD_GetMacds(in, current);
        }
        case 9:
        {
            return _iceD_GetMas(in, current);
        }
        case 10:
        {
            return _iceD_GetOneAtr(in, current);
        }
        case 11:
        {
            return _iceD_GetOneDivType(in, current);
        }
        case 12:
        {
            return _iceD_GetOneEma(in, current);
        }
        case 13:
        {
            return _iceD_GetOneKLine(in, current);
        }
        case 14:
        {
            return _iceD_GetOneMa(in, current);
        }
        case 15:
        {
            return _iceD_GetOneMacd(in, current);
        }
        case 16:
        {
            return _iceD_GetOneTick(in, current);
        }
        case 17:
        {
            return _iceD_GetOneVwMa(in, current);
        }
        case 18:
        {
            return _iceD_GetTicks(in, current);
        }
        case 19:
        {
            return _iceD_GetVwMas(in, current);
        }
        case 20:
        {
            return _iceD_IdlCount(in, current);
        }
        case 21:
        {
            return _iceD_IsAllIdle(in, current);
        }
        case 22:
        {
            return _iceD_RecountAllIndex(in, current);
        }
        case 23:
        {
            return _iceD_RemoveAllKLines(in, current);
        }
        case 24:
        {
            return _iceD_RemoveAllTicks(in, current);
        }
        case 25:
        {
            return _iceD_RemoveKLinesByRange(in, current);
        }
        case 26:
        {
            return _iceD_RemoveOneKLine(in, current);
        }
        case 27:
        {
            return _iceD_RemoveTicksByRange(in, current);
        }
        case 28:
        {
            return _iceD_TaskCount(in, current);
        }
        case 29:
        {
            return _iceD_UpdateAllIndexFromTimePos(in, current);
        }
        case 30:
        {
            return _iceD_UpdateKLine(in, current);
        }
        case 31:
        {
            return _iceD_UpdateKLines(in, current);
        }
        case 32:
        {
            return _iceD_UpdateTickToDB(in, current);
        }
        case 33:
        {
            return _iceD_ice_id(in, current);
        }
        case 34:
        {
            return _iceD_ice_ids(in, current);
        }
        case 35:
        {
            return _iceD_ice_isA(in, current);
        }
        case 36:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
IBTrader::IQDatabase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< IQDatabase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
IBTrader::IQDatabase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< IQDatabase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::_icePatchObjectPtr(IQDatabasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = IQDatabasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(IQDatabase::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
