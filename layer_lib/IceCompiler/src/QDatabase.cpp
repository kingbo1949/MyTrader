//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `QDatabase.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <QDatabase.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_IBTrader_IQDatabase_ids[2] =
{
    "::IBTrader::IQDatabase",
    "::Ice::Object"
};
const ::std::string iceC_IBTrader_IQDatabase_ops[] =
{
    "GetAvgAtrs",
    "GetDivTypes",
    "GetEmas",
    "GetInvalidKLines",
    "GetKLinePairs",
    "GetKLines",
    "GetLastUpdateTick",
    "GetMacds",
    "GetMas",
    "GetOneAvgAtr",
    "GetOneDivType",
    "GetOneEma",
    "GetOneKLine",
    "GetOneMa",
    "GetOneMacd",
    "GetOneTick",
    "GetOneVwMa",
    "GetTicks",
    "GetVwMas",
    "RecountAvgAtr",
    "RecountAvgAtrFromTimePos",
    "RecountDivType",
    "RecountDivTypeFromTimePos",
    "RecountEma",
    "RecountEmaFromTimePos",
    "RecountMa",
    "RecountMaFromTimePos",
    "RecountMacd",
    "RecountMacdFromTimePos",
    "RecountVwMa",
    "RecountVwMaFromTimePos",
    "RemoveAllAvgAtrs",
    "RemoveAllDivTypes",
    "RemoveAllEmas",
    "RemoveAllKLines",
    "RemoveAllMacds",
    "RemoveAllMas",
    "RemoveAllTicks",
    "RemoveAllVwMas",
    "RemoveAvgAtrsByRange",
    "RemoveDivTypesByRange",
    "RemoveEmasByRange",
    "RemoveKLinesByRange",
    "RemoveMacdsByRange",
    "RemoveMasByRange",
    "RemoveOneKLine",
    "RemoveTicksByRange",
    "RemoveVwMasByRange",
    "UpdateAvgAtr",
    "UpdateDivType",
    "UpdateEma",
    "UpdateKLine",
    "UpdateMa",
    "UpdateMacd",
    "UpdateTickToDB",
    "UpdateVwMa",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_IBTrader_IQDatabase_UpdateTickToDB_name = "UpdateTickToDB";
const ::std::string iceC_IBTrader_IQDatabase_GetLastUpdateTick_name = "GetLastUpdateTick";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllTicks_name = "RemoveAllTicks";
const ::std::string iceC_IBTrader_IQDatabase_RemoveTicksByRange_name = "RemoveTicksByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetTicks_name = "GetTicks";
const ::std::string iceC_IBTrader_IQDatabase_GetOneTick_name = "GetOneTick";
const ::std::string iceC_IBTrader_IQDatabase_UpdateKLine_name = "UpdateKLine";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllKLines_name = "RemoveAllKLines";
const ::std::string iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name = "RemoveKLinesByRange";
const ::std::string iceC_IBTrader_IQDatabase_RemoveOneKLine_name = "RemoveOneKLine";
const ::std::string iceC_IBTrader_IQDatabase_GetKLines_name = "GetKLines";
const ::std::string iceC_IBTrader_IQDatabase_GetOneKLine_name = "GetOneKLine";
const ::std::string iceC_IBTrader_IQDatabase_GetKLinePairs_name = "GetKLinePairs";
const ::std::string iceC_IBTrader_IQDatabase_GetInvalidKLines_name = "GetInvalidKLines";
const ::std::string iceC_IBTrader_IQDatabase_RecountMa_name = "RecountMa";
const ::std::string iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name = "RecountMaFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_UpdateMa_name = "UpdateMa";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllMas_name = "RemoveAllMas";
const ::std::string iceC_IBTrader_IQDatabase_RemoveMasByRange_name = "RemoveMasByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetMas_name = "GetMas";
const ::std::string iceC_IBTrader_IQDatabase_GetOneMa_name = "GetOneMa";
const ::std::string iceC_IBTrader_IQDatabase_RecountVwMa_name = "RecountVwMa";
const ::std::string iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name = "RecountVwMaFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_UpdateVwMa_name = "UpdateVwMa";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllVwMas_name = "RemoveAllVwMas";
const ::std::string iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name = "RemoveVwMasByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetVwMas_name = "GetVwMas";
const ::std::string iceC_IBTrader_IQDatabase_GetOneVwMa_name = "GetOneVwMa";
const ::std::string iceC_IBTrader_IQDatabase_RecountEma_name = "RecountEma";
const ::std::string iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name = "RecountEmaFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_UpdateEma_name = "UpdateEma";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllEmas_name = "RemoveAllEmas";
const ::std::string iceC_IBTrader_IQDatabase_RemoveEmasByRange_name = "RemoveEmasByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetEmas_name = "GetEmas";
const ::std::string iceC_IBTrader_IQDatabase_GetOneEma_name = "GetOneEma";
const ::std::string iceC_IBTrader_IQDatabase_RecountMacd_name = "RecountMacd";
const ::std::string iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name = "RecountMacdFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_UpdateMacd_name = "UpdateMacd";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllMacds_name = "RemoveAllMacds";
const ::std::string iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name = "RemoveMacdsByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetMacds_name = "GetMacds";
const ::std::string iceC_IBTrader_IQDatabase_GetOneMacd_name = "GetOneMacd";
const ::std::string iceC_IBTrader_IQDatabase_RecountDivType_name = "RecountDivType";
const ::std::string iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name = "RecountDivTypeFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_UpdateDivType_name = "UpdateDivType";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name = "RemoveAllDivTypes";
const ::std::string iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name = "RemoveDivTypesByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetDivTypes_name = "GetDivTypes";
const ::std::string iceC_IBTrader_IQDatabase_GetOneDivType_name = "GetOneDivType";
const ::std::string iceC_IBTrader_IQDatabase_RecountAvgAtr_name = "RecountAvgAtr";
const ::std::string iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name = "RecountAvgAtrFromTimePos";
const ::std::string iceC_IBTrader_IQDatabase_UpdateAvgAtr_name = "UpdateAvgAtr";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name = "RemoveAllAvgAtrs";
const ::std::string iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name = "RemoveAvgAtrsByRange";
const ::std::string iceC_IBTrader_IQDatabase_GetAvgAtrs_name = "GetAvgAtrs";
const ::std::string iceC_IBTrader_IQDatabase_GetOneAvgAtr_name = "GetOneAvgAtr";

}

bool
IBTrader::IQDatabase::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IBTrader_IQDatabase_ids, iceC_IBTrader_IQDatabase_ids + 2, s);
}

::std::vector<::std::string>
IBTrader::IQDatabase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IBTrader_IQDatabase_ids[0], &iceC_IBTrader_IQDatabase_ids[2]);
}

::std::string
IBTrader::IQDatabase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IBTrader::IQDatabase::ice_staticId()
{
    static const ::std::string typeId = "::IBTrader::IQDatabase";
    return typeId;
}

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateTickToDB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ITick iceP_tick;
    istr->readAll(iceP_tick);
    inS.endReadParams();
    this->UpdateTickToDB(::std::move(iceP_tick), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetLastUpdateTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int iceP_updateCount;
    long long int iceP_recentUpdateSecnd;
    ITick ret = this->GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_updateCount, iceP_recentUpdateSecnd, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    istr->readAll(iceP_codeId);
    inS.endReadParams();
    this->RemoveAllTicks(::std::move(iceP_codeId), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveTicksByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveTicksByRange(::std::move(iceP_codeId), iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_query);
    inS.endReadParams();
    ITicks iceP_ticks;
    this->GetTicks(::std::move(iceP_codeId), ::std::move(iceP_query), iceP_ticks, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ticks);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timePos);
    inS.endReadParams();
    ITick iceP_tick;
    bool ret = this->GetOneTick(::std::move(iceP_codeId), iceP_timePos, iceP_tick, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_tick, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IKLine iceP_kline;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_kline);
    inS.endReadParams();
    this->UpdateKLine(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_kline), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllKLines(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveKLinesByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveKLinesByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RemoveOneKLine(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetKLines(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_klines, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IKLine iceP_kline;
    bool ret = this->GetOneKLine(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_kline, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_kline, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLinePairs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_first;
    ::std::string iceP_second;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_first, iceP_second, iceP_timeType, iceP_query);
    inS.endReadParams();
    IKLinePairs iceP_kLinePairs;
    this->GetKLinePairs(::std::move(iceP_first), ::std::move(iceP_second), iceP_timeType, ::std::move(iceP_query), iceP_kLinePairs, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_kLinePairs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetInvalidKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetInvalidKLines(::std::move(iceP_codeId), iceP_timeType, iceP_klines, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountMa(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMaFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RecountMaFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IAvgValue iceP_ma;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_ma);
    inS.endReadParams();
    this->UpdateMa(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_ma), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllMas(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveMasByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveMasByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetMas(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_mas, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneMa(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ma, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ma, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountVwMa(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountVwMaFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RecountVwMaFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IAvgValue iceP_ma;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_ma);
    inS.endReadParams();
    this->UpdateVwMa(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_ma), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllVwMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllVwMas(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveVwMasByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveVwMasByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetVwMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetVwMas(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_mas, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneVwMa(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ma, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ma, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountEma(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountEmaFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RecountEmaFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IAvgValue iceP_ema;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_ema);
    inS.endReadParams();
    this->UpdateEma(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_ema), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllEmas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllEmas(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveEmasByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveEmasByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetEmas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgValues iceP_emas;
    this->GetEmas(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_emas, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_emas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ema;
    bool ret = this->GetOneEma(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ema, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ema, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountMacd(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMacdFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RecountMacdFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IMacdValue iceP_macd;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_macd);
    inS.endReadParams();
    this->UpdateMacd(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_macd), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllMacds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllMacds(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveMacdsByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveMacdsByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMacds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IMacdValues iceP_macds;
    this->GetMacds(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_macds, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_macds);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IMacdValue iceP_ma;
    bool ret = this->GetOneMacd(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_ma, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_ma, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountDivType(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountDivTypeFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RecountDivTypeFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IDivTypeValue iceP_divtype;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_divtype);
    inS.endReadParams();
    this->UpdateDivType(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_divtype), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllDivTypes(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllDivTypes(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveDivTypesByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveDivTypesByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetDivTypes(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IDivTypeValues iceP_divtypes;
    this->GetDivTypes(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_divtypes, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_divtypes);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    IDivTypeValue iceP_divtype;
    bool ret = this->GetOneDivType(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_divtype, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_divtype, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountAvgAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RecountAvgAtr(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountAvgAtrFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    this->RecountAvgAtrFromTimePos(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateAvgAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    double iceP_avgAtr;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_avgAtr);
    inS.endReadParams();
    this->UpdateAvgAtr(::std::move(iceP_codeId), iceP_timeType, iceP_avgAtr, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllAvgAtrs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->readAll(iceP_codeId, iceP_timeType);
    inS.endReadParams();
    this->RemoveAllAvgAtrs(::std::move(iceP_codeId), iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAvgAtrsByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_beginTime;
    long long int iceP_endTime;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
    inS.endReadParams();
    this->RemoveAvgAtrsByRange(::std::move(iceP_codeId), iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetAvgAtrs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_query);
    inS.endReadParams();
    IAvgAtrs iceP_avgAtrs;
    this->GetAvgAtrs(::std::move(iceP_codeId), iceP_timeType, ::std::move(iceP_query), iceP_avgAtrs, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_avgAtrs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneAvgAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    long long int iceP_timePos;
    istr->readAll(iceP_codeId, iceP_timeType, iceP_timePos);
    inS.endReadParams();
    double iceP_avgAtr;
    bool ret = this->GetOneAvgAtr(::std::move(iceP_codeId), iceP_timeType, iceP_timePos, iceP_avgAtr, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_avgAtr, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IBTrader_IQDatabase_ops, iceC_IBTrader_IQDatabase_ops + 60, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IBTrader_IQDatabase_ops)
    {
        case 0:
        {
            return _iceD_GetAvgAtrs(in, current);
        }
        case 1:
        {
            return _iceD_GetDivTypes(in, current);
        }
        case 2:
        {
            return _iceD_GetEmas(in, current);
        }
        case 3:
        {
            return _iceD_GetInvalidKLines(in, current);
        }
        case 4:
        {
            return _iceD_GetKLinePairs(in, current);
        }
        case 5:
        {
            return _iceD_GetKLines(in, current);
        }
        case 6:
        {
            return _iceD_GetLastUpdateTick(in, current);
        }
        case 7:
        {
            return _iceD_GetMacds(in, current);
        }
        case 8:
        {
            return _iceD_GetMas(in, current);
        }
        case 9:
        {
            return _iceD_GetOneAvgAtr(in, current);
        }
        case 10:
        {
            return _iceD_GetOneDivType(in, current);
        }
        case 11:
        {
            return _iceD_GetOneEma(in, current);
        }
        case 12:
        {
            return _iceD_GetOneKLine(in, current);
        }
        case 13:
        {
            return _iceD_GetOneMa(in, current);
        }
        case 14:
        {
            return _iceD_GetOneMacd(in, current);
        }
        case 15:
        {
            return _iceD_GetOneTick(in, current);
        }
        case 16:
        {
            return _iceD_GetOneVwMa(in, current);
        }
        case 17:
        {
            return _iceD_GetTicks(in, current);
        }
        case 18:
        {
            return _iceD_GetVwMas(in, current);
        }
        case 19:
        {
            return _iceD_RecountAvgAtr(in, current);
        }
        case 20:
        {
            return _iceD_RecountAvgAtrFromTimePos(in, current);
        }
        case 21:
        {
            return _iceD_RecountDivType(in, current);
        }
        case 22:
        {
            return _iceD_RecountDivTypeFromTimePos(in, current);
        }
        case 23:
        {
            return _iceD_RecountEma(in, current);
        }
        case 24:
        {
            return _iceD_RecountEmaFromTimePos(in, current);
        }
        case 25:
        {
            return _iceD_RecountMa(in, current);
        }
        case 26:
        {
            return _iceD_RecountMaFromTimePos(in, current);
        }
        case 27:
        {
            return _iceD_RecountMacd(in, current);
        }
        case 28:
        {
            return _iceD_RecountMacdFromTimePos(in, current);
        }
        case 29:
        {
            return _iceD_RecountVwMa(in, current);
        }
        case 30:
        {
            return _iceD_RecountVwMaFromTimePos(in, current);
        }
        case 31:
        {
            return _iceD_RemoveAllAvgAtrs(in, current);
        }
        case 32:
        {
            return _iceD_RemoveAllDivTypes(in, current);
        }
        case 33:
        {
            return _iceD_RemoveAllEmas(in, current);
        }
        case 34:
        {
            return _iceD_RemoveAllKLines(in, current);
        }
        case 35:
        {
            return _iceD_RemoveAllMacds(in, current);
        }
        case 36:
        {
            return _iceD_RemoveAllMas(in, current);
        }
        case 37:
        {
            return _iceD_RemoveAllTicks(in, current);
        }
        case 38:
        {
            return _iceD_RemoveAllVwMas(in, current);
        }
        case 39:
        {
            return _iceD_RemoveAvgAtrsByRange(in, current);
        }
        case 40:
        {
            return _iceD_RemoveDivTypesByRange(in, current);
        }
        case 41:
        {
            return _iceD_RemoveEmasByRange(in, current);
        }
        case 42:
        {
            return _iceD_RemoveKLinesByRange(in, current);
        }
        case 43:
        {
            return _iceD_RemoveMacdsByRange(in, current);
        }
        case 44:
        {
            return _iceD_RemoveMasByRange(in, current);
        }
        case 45:
        {
            return _iceD_RemoveOneKLine(in, current);
        }
        case 46:
        {
            return _iceD_RemoveTicksByRange(in, current);
        }
        case 47:
        {
            return _iceD_RemoveVwMasByRange(in, current);
        }
        case 48:
        {
            return _iceD_UpdateAvgAtr(in, current);
        }
        case 49:
        {
            return _iceD_UpdateDivType(in, current);
        }
        case 50:
        {
            return _iceD_UpdateEma(in, current);
        }
        case 51:
        {
            return _iceD_UpdateKLine(in, current);
        }
        case 52:
        {
            return _iceD_UpdateMa(in, current);
        }
        case 53:
        {
            return _iceD_UpdateMacd(in, current);
        }
        case 54:
        {
            return _iceD_UpdateTickToDB(in, current);
        }
        case 55:
        {
            return _iceD_UpdateVwMa(in, current);
        }
        case 56:
        {
            return _iceD_ice_id(in, current);
        }
        case 57:
        {
            return _iceD_ice_ids(in, current);
        }
        case 58:
        {
            return _iceD_ice_isA(in, current);
        }
        case 59:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateTickToDB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ITick& iceP_tick, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateTickToDB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_tick);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetLastUpdateTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetLastUpdateTickResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetLastUpdateTickResult v;
            istr->readAll(v.updateCount, v.recentUpdateSecnd, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllTicks_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveTicksByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveTicksByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::ITicks>>& outAsync, const ::std::string& iceP_codeId, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetTicks_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetTicks_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneTickResult>>& outAsync, const ::std::string& iceP_codeId, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneTick_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneTick_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneTickResult v;
            istr->readAll(v.tick, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IKLine& iceP_kline, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateKLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_kline);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveKLinesByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveOneKLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLines_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneKLineResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneKLine_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneKLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneKLineResult v;
            istr->readAll(v.kline, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetKLinePairs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLinePairs>>& outAsync, const ::std::string& iceP_first, const ::std::string& iceP_second, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetKLinePairs_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_first, iceP_second, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetInvalidKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetInvalidKLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountMaFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IAvgValue& iceP_ma, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_ma);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllMas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveMasByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveMasByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMas_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetMas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMaResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMa_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneMaResult v;
            istr->readAll(v.ma, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountVwMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountVwMaFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IAvgValue& iceP_ma, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateVwMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_ma);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllVwMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllVwMas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveVwMasByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetVwMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetVwMas_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetVwMas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneVwMaResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneVwMa_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneVwMaResult v;
            istr->readAll(v.ma, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountEma_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountEmaFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IAvgValue& iceP_ema, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateEma_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_ema);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllEmas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllEmas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveEmasByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveEmasByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetEmas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetEmas_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetEmas_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneEmaResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneEma_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneEma_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneEmaResult v;
            istr->readAll(v.ema, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountMacd_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountMacdFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IMacdValue& iceP_macd, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateMacd_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_macd);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllMacds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllMacds_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveMacdsByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetMacds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IMacdValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMacds_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetMacds_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMacdResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMacd_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneMacd_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneMacdResult v;
            istr->readAll(v.ma, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountDivType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountDivTypeFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IDivTypeValue& iceP_divtype, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateDivType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_divtype);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllDivTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveDivTypesByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetDivTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IDivTypeValues>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetDivTypes_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetDivTypes_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneDivTypeResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneDivType_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneDivType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneDivTypeResult v;
            istr->readAll(v.divtype, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountAvgAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountAvgAtr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RecountAvgAtrFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_UpdateAvgAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, double iceP_avgAtr, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_UpdateAvgAtr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_avgAtr);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAllAvgAtrs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_RemoveAvgAtrsByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_beginTime, long long int iceP_endTime, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetAvgAtrs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgAtrs>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, const IQuery& iceP_query, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetAvgAtrs_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetAvgAtrs_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_query);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::IQDatabasePrx::_iceI_GetOneAvgAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneAvgAtrResult>>& outAsync, const ::std::string& iceP_codeId, ITimeType iceP_timeType, long long int iceP_timePos, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneAvgAtr_name);
    outAsync->invoke(iceC_IBTrader_IQDatabase_GetOneAvgAtr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_codeId, iceP_timeType, iceP_timePos);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            IQDatabase::GetOneAvgAtrResult v;
            istr->readAll(v.avgAtr, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
IBTrader::IQDatabasePrx::_newInstance() const
{
    return ::IceInternal::createProxy<IQDatabasePrx>();
}
/// \endcond

const ::std::string&
IBTrader::IQDatabasePrx::ice_staticId()
{
    return IQDatabase::ice_staticId();
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_IBTrader_IQDatabase_UpdateTickToDB_name = "UpdateTickToDB";

const ::std::string iceC_IBTrader_IQDatabase_GetLastUpdateTick_name = "GetLastUpdateTick";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllTicks_name = "RemoveAllTicks";

const ::std::string iceC_IBTrader_IQDatabase_RemoveTicksByRange_name = "RemoveTicksByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetTicks_name = "GetTicks";

const ::std::string iceC_IBTrader_IQDatabase_GetOneTick_name = "GetOneTick";

const ::std::string iceC_IBTrader_IQDatabase_UpdateKLine_name = "UpdateKLine";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllKLines_name = "RemoveAllKLines";

const ::std::string iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name = "RemoveKLinesByRange";

const ::std::string iceC_IBTrader_IQDatabase_RemoveOneKLine_name = "RemoveOneKLine";

const ::std::string iceC_IBTrader_IQDatabase_GetKLines_name = "GetKLines";

const ::std::string iceC_IBTrader_IQDatabase_GetOneKLine_name = "GetOneKLine";

const ::std::string iceC_IBTrader_IQDatabase_GetKLinePairs_name = "GetKLinePairs";

const ::std::string iceC_IBTrader_IQDatabase_GetInvalidKLines_name = "GetInvalidKLines";

const ::std::string iceC_IBTrader_IQDatabase_RecountMa_name = "RecountMa";

const ::std::string iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name = "RecountMaFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_UpdateMa_name = "UpdateMa";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllMas_name = "RemoveAllMas";

const ::std::string iceC_IBTrader_IQDatabase_RemoveMasByRange_name = "RemoveMasByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetMas_name = "GetMas";

const ::std::string iceC_IBTrader_IQDatabase_GetOneMa_name = "GetOneMa";

const ::std::string iceC_IBTrader_IQDatabase_RecountVwMa_name = "RecountVwMa";

const ::std::string iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name = "RecountVwMaFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_UpdateVwMa_name = "UpdateVwMa";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllVwMas_name = "RemoveAllVwMas";

const ::std::string iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name = "RemoveVwMasByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetVwMas_name = "GetVwMas";

const ::std::string iceC_IBTrader_IQDatabase_GetOneVwMa_name = "GetOneVwMa";

const ::std::string iceC_IBTrader_IQDatabase_RecountEma_name = "RecountEma";

const ::std::string iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name = "RecountEmaFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_UpdateEma_name = "UpdateEma";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllEmas_name = "RemoveAllEmas";

const ::std::string iceC_IBTrader_IQDatabase_RemoveEmasByRange_name = "RemoveEmasByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetEmas_name = "GetEmas";

const ::std::string iceC_IBTrader_IQDatabase_GetOneEma_name = "GetOneEma";

const ::std::string iceC_IBTrader_IQDatabase_RecountMacd_name = "RecountMacd";

const ::std::string iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name = "RecountMacdFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_UpdateMacd_name = "UpdateMacd";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllMacds_name = "RemoveAllMacds";

const ::std::string iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name = "RemoveMacdsByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetMacds_name = "GetMacds";

const ::std::string iceC_IBTrader_IQDatabase_GetOneMacd_name = "GetOneMacd";

const ::std::string iceC_IBTrader_IQDatabase_RecountDivType_name = "RecountDivType";

const ::std::string iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name = "RecountDivTypeFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_UpdateDivType_name = "UpdateDivType";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name = "RemoveAllDivTypes";

const ::std::string iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name = "RemoveDivTypesByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetDivTypes_name = "GetDivTypes";

const ::std::string iceC_IBTrader_IQDatabase_GetOneDivType_name = "GetOneDivType";

const ::std::string iceC_IBTrader_IQDatabase_RecountAvgAtr_name = "RecountAvgAtr";

const ::std::string iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name = "RecountAvgAtrFromTimePos";

const ::std::string iceC_IBTrader_IQDatabase_UpdateAvgAtr_name = "UpdateAvgAtr";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name = "RemoveAllAvgAtrs";

const ::std::string iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name = "RemoveAvgAtrsByRange";

const ::std::string iceC_IBTrader_IQDatabase_GetAvgAtrs_name = "GetAvgAtrs";

const ::std::string iceC_IBTrader_IQDatabase_GetOneAvgAtr_name = "GetOneAvgAtr";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::IBTrader::upCast(IQDatabase* p) { return p; }

void
::IceProxy::IBTrader::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< IQDatabase>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new IQDatabase;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateTickToDB(const ::IBTrader::ITick& iceP_tick, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateTickToDB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateTickToDB_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_tick);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateTickToDB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateTickToDB(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateTickToDB_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetLastUpdateTick(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::IBTrader::ITick
IceProxy::IBTrader::IQDatabase::end_GetLastUpdateTick(::Ice::Int& iceP_updateCount, ::Ice::Long& iceP_recentUpdateSecnd, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    ::IBTrader::ITick ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_updateCount);
    istr->read(iceP_recentUpdateSecnd);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetLastUpdateTick(::Ice::Int& iceP_updateCount, ::Ice::Long& iceP_recentUpdateSecnd, ::IBTrader::ITick& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetLastUpdateTick_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_updateCount);
    istr->read(iceP_recentUpdateSecnd);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllTicks(const ::std::string& iceP_codeId, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllTicks_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllTicks_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllTicks_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllTicks(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllTicks_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveTicksByRange(const ::std::string& iceP_codeId, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveTicksByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveTicksByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveTicksByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveTicksByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveTicksByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetTicks(const ::std::string& iceP_codeId, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetTicks_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetTicks_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetTicks_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetTicks_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetTicks(::IBTrader::ITicks& iceP_ticks, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetTicks_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ticks);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetTicks(::IBTrader::ITicks& iceP_ticks, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetTicks_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ticks);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneTick(const ::std::string& iceP_codeId, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneTick_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneTick_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneTick_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneTick_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneTick(::IBTrader::ITick& iceP_tick, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneTick_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_tick);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneTick(::IBTrader::ITick& iceP_tick, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneTick_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_tick);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateKLine(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IKLine& iceP_kline, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateKLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateKLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_kline);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateKLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateKLine(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateKLine_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllKLines(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllKLines_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveKLinesByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveKLinesByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveKLinesByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveOneKLine(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveOneKLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveOneKLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveOneKLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveOneKLine(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveOneKLine_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLines_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneKLine(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneKLine_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneKLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneKLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneKLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneKLine(::IBTrader::IKLine& iceP_kline, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneKLine_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kline);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneKLine(::IBTrader::IKLine& iceP_kline, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneKLine_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kline);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetKLinePairs(const ::std::string& iceP_first, const ::std::string& iceP_second, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetKLinePairs_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetKLinePairs_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetKLinePairs_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_first);
        ostr->write(iceP_second);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetKLinePairs(::IBTrader::IKLinePairs& iceP_kLinePairs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kLinePairs);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetKLinePairs(::IBTrader::IKLinePairs& iceP_kLinePairs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetKLinePairs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_kLinePairs);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetInvalidKLines(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetInvalidKLines_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetInvalidKLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetInvalidKLines_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetInvalidKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetInvalidKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetInvalidKLines_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_klines);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountMa(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountMa_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountMaFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountMaFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountMaFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IAvgValue& iceP_ma, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_ma);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateMa(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateMa_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllMas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllMas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllMas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllMas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllMas(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllMas_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveMasByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveMasByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveMasByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveMasByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveMasByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveMasByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetMas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMas_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetMas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetMas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetMas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMa_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneMa(::IBTrader::IAvgValue& iceP_ma, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMa_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMa_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountVwMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountVwMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountVwMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountVwMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountVwMa(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountVwMa_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountVwMaFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountVwMaFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountVwMaFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateVwMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IAvgValue& iceP_ma, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateVwMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateVwMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_ma);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateVwMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateVwMa(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateVwMa_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllVwMas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllVwMas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllVwMas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllVwMas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllVwMas(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllVwMas_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveVwMasByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveVwMasByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveVwMasByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetVwMas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetVwMas_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetVwMas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetVwMas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetVwMas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetVwMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetVwMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetVwMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetVwMas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_mas);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneVwMa(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneVwMa_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneVwMa_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneVwMa_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneVwMa(::IBTrader::IAvgValue& iceP_ma, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneVwMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneVwMa_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountEma(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountEma_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountEma_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountEma_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountEma(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountEma_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountEmaFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountEmaFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountEmaFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateEma(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IAvgValue& iceP_ema, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateEma_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateEma_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_ema);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateEma_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateEma(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateEma_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllEmas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllEmas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllEmas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllEmas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllEmas(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllEmas_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveEmasByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveEmasByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveEmasByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveEmasByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveEmasByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveEmasByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetEmas(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetEmas_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetEmas_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetEmas_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetEmas_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetEmas(::IBTrader::IAvgValues& iceP_emas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetEmas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_emas);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetEmas(::IBTrader::IAvgValues& iceP_emas, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetEmas_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_emas);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneEma(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneEma_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneEma_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneEma_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneEma_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneEma(::IBTrader::IAvgValue& iceP_ema, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneEma_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ema);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneEma(::IBTrader::IAvgValue& iceP_ema, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneEma_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ema);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountMacd(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountMacd_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountMacd_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountMacd_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountMacd(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountMacd_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountMacdFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountMacdFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountMacdFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateMacd(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IMacdValue& iceP_macd, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateMacd_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateMacd_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_macd);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateMacd_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateMacd(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateMacd_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllMacds(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllMacds_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllMacds_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllMacds_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllMacds(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllMacds_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveMacdsByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveMacdsByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveMacdsByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetMacds(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetMacds_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetMacds_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetMacds_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetMacds_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetMacds(::IBTrader::IMacdValues& iceP_macds, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMacds_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_macds);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetMacds(::IBTrader::IMacdValues& iceP_macds, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetMacds_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_macds);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneMacd(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneMacd_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneMacd_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneMacd_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneMacd_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneMacd(::IBTrader::IMacdValue& iceP_ma, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMacd_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneMacd(::IBTrader::IMacdValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneMacd_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_ma);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountDivType(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountDivType_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountDivType_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountDivType_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountDivType(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountDivType_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountDivTypeFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountDivTypeFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountDivTypeFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateDivType(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IDivTypeValue& iceP_divtype, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateDivType_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateDivType_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_divtype);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateDivType_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateDivType(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateDivType_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllDivTypes(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllDivTypes(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllDivTypes_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveDivTypesByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveDivTypesByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveDivTypesByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetDivTypes(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetDivTypes_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetDivTypes_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetDivTypes_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetDivTypes_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetDivTypes(::IBTrader::IDivTypeValues& iceP_divtypes, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetDivTypes_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtypes);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetDivTypes(::IBTrader::IDivTypeValues& iceP_divtypes, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetDivTypes_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtypes);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneDivType(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneDivType_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneDivType_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneDivType_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneDivType_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneDivType(::IBTrader::IDivTypeValue& iceP_divtype, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneDivType_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtype);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneDivType(::IBTrader::IDivTypeValue& iceP_divtype, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneDivType_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_divtype);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountAvgAtr(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountAvgAtr_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountAvgAtr_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountAvgAtr_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountAvgAtr(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountAvgAtr_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RecountAvgAtrFromTimePos(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RecountAvgAtrFromTimePos(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RecountAvgAtrFromTimePos_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_UpdateAvgAtr(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Double iceP_avgAtr, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_UpdateAvgAtr_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_UpdateAvgAtr_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_avgAtr);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_UpdateAvgAtr_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_UpdateAvgAtr(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_UpdateAvgAtr_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAllAvgAtrs(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAllAvgAtrs(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAllAvgAtrs_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_RemoveAvgAtrsByRange(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_beginTime, ::Ice::Long iceP_endTime, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_beginTime);
        ostr->write(iceP_endTime);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_RemoveAvgAtrsByRange(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_IBTrader_IQDatabase_RemoveAvgAtrsByRange_name);
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetAvgAtrs(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, const ::IBTrader::IQuery& iceP_query, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetAvgAtrs_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetAvgAtrs_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetAvgAtrs_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_query);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetAvgAtrs_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::IBTrader::IQDatabase::end_GetAvgAtrs(::IBTrader::IAvgAtrs& iceP_avgAtrs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetAvgAtrs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtrs);
    result->_endReadParams();
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetAvgAtrs(::IBTrader::IAvgAtrs& iceP_avgAtrs, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetAvgAtrs_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtrs);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::IBTrader::IQDatabase::_iceI_begin_GetOneAvgAtr(const ::std::string& iceP_codeId, ::IBTrader::ITimeType iceP_timeType, ::Ice::Long iceP_timePos, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_IBTrader_IQDatabase_GetOneAvgAtr_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_IBTrader_IQDatabase_GetOneAvgAtr_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_IBTrader_IQDatabase_GetOneAvgAtr_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_codeId);
        ostr->write(iceP_timeType);
        ostr->write(iceP_timePos);
        result->endWriteParams();
        result->invoke(iceC_IBTrader_IQDatabase_GetOneAvgAtr_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::IBTrader::IQDatabase::end_GetOneAvgAtr(::Ice::Double& iceP_avgAtr, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneAvgAtr_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtr);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::IBTrader::IQDatabase::_iceI_end_GetOneAvgAtr(::Ice::Double& iceP_avgAtr, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_IBTrader_IQDatabase_GetOneAvgAtr_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_avgAtr);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::IBTrader::IQDatabase::_newInstance() const
{
    return new IQDatabase;
}
/// \endcond

const ::std::string&
IceProxy::IBTrader::IQDatabase::ice_staticId()
{
    return ::IBTrader::IQDatabase::ice_staticId();
}

IBTrader::IQDatabase::~IQDatabase()
{
}

/// \cond INTERNAL
::Ice::Object* IBTrader::upCast(IQDatabase* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_IBTrader_IQDatabase_ids[2] =
{
    "::IBTrader::IQDatabase",
    "::Ice::Object"
};

}

bool
IBTrader::IQDatabase::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IBTrader_IQDatabase_ids, iceC_IBTrader_IQDatabase_ids + 2, s);
}

::std::vector< ::std::string>
IBTrader::IQDatabase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_IBTrader_IQDatabase_ids[0], &iceC_IBTrader_IQDatabase_ids[2]);
}

const ::std::string&
IBTrader::IQDatabase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IBTrader::IQDatabase::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::IBTrader::IQDatabase";
    return typeId;
#else
    return iceC_IBTrader_IQDatabase_ids[0];
#endif
}

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateTickToDB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ITick iceP_tick;
    istr->read(iceP_tick);
    inS.endReadParams();
    this->UpdateTickToDB(iceP_tick, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetLastUpdateTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int iceP_updateCount;
    ::Ice::Long iceP_recentUpdateSecnd;
    ITick ret = this->GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_updateCount);
    ostr->write(iceP_recentUpdateSecnd);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    istr->read(iceP_codeId);
    inS.endReadParams();
    this->RemoveAllTicks(iceP_codeId, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveTicksByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveTicksByRange(iceP_codeId, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetTicks(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_query);
    inS.endReadParams();
    ITicks iceP_ticks;
    this->GetTicks(iceP_codeId, iceP_query, iceP_ticks, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ticks);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneTick(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timePos);
    inS.endReadParams();
    ITick iceP_tick;
    bool ret = this->GetOneTick(iceP_codeId, iceP_timePos, iceP_tick, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_tick);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IKLine iceP_kline;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_kline);
    inS.endReadParams();
    this->UpdateKLine(iceP_codeId, iceP_timeType, iceP_kline, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllKLines(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveKLinesByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveKLinesByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RemoveOneKLine(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetKLines(iceP_codeId, iceP_timeType, iceP_query, iceP_klines, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneKLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IKLine iceP_kline;
    bool ret = this->GetOneKLine(iceP_codeId, iceP_timeType, iceP_timePos, iceP_kline, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_kline);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetKLinePairs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_first;
    ::std::string iceP_second;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_first);
    istr->read(iceP_second);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IKLinePairs iceP_kLinePairs;
    this->GetKLinePairs(iceP_first, iceP_second, iceP_timeType, iceP_query, iceP_kLinePairs, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_kLinePairs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetInvalidKLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    IKLines iceP_klines;
    this->GetInvalidKLines(iceP_codeId, iceP_timeType, iceP_klines, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_klines);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountMa(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMaFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RecountMaFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IAvgValue iceP_ma;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_ma);
    inS.endReadParams();
    this->UpdateMa(iceP_codeId, iceP_timeType, iceP_ma, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllMas(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveMasByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveMasByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetMas(iceP_codeId, iceP_timeType, iceP_query, iceP_mas, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneMa(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ma, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ma);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountVwMa(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountVwMaFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RecountVwMaFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IAvgValue iceP_ma;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_ma);
    inS.endReadParams();
    this->UpdateVwMa(iceP_codeId, iceP_timeType, iceP_ma, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllVwMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllVwMas(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveVwMasByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveVwMasByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetVwMas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgValues iceP_mas;
    this->GetVwMas(iceP_codeId, iceP_timeType, iceP_query, iceP_mas, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_mas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneVwMa(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ma;
    bool ret = this->GetOneVwMa(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ma, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ma);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountEma(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountEmaFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RecountEmaFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IAvgValue iceP_ema;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_ema);
    inS.endReadParams();
    this->UpdateEma(iceP_codeId, iceP_timeType, iceP_ema, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllEmas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllEmas(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveEmasByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveEmasByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetEmas(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgValues iceP_emas;
    this->GetEmas(iceP_codeId, iceP_timeType, iceP_query, iceP_emas, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_emas);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneEma(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IAvgValue iceP_ema;
    bool ret = this->GetOneEma(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ema, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ema);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountMacd(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountMacdFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RecountMacdFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IMacdValue iceP_macd;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_macd);
    inS.endReadParams();
    this->UpdateMacd(iceP_codeId, iceP_timeType, iceP_macd, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllMacds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllMacds(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveMacdsByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveMacdsByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetMacds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IMacdValues iceP_macds;
    this->GetMacds(iceP_codeId, iceP_timeType, iceP_query, iceP_macds, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_macds);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneMacd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IMacdValue iceP_ma;
    bool ret = this->GetOneMacd(iceP_codeId, iceP_timeType, iceP_timePos, iceP_ma, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_ma);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountDivType(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountDivTypeFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RecountDivTypeFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IDivTypeValue iceP_divtype;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_divtype);
    inS.endReadParams();
    this->UpdateDivType(iceP_codeId, iceP_timeType, iceP_divtype, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllDivTypes(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllDivTypes(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveDivTypesByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveDivTypesByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetDivTypes(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IDivTypeValues iceP_divtypes;
    this->GetDivTypes(iceP_codeId, iceP_timeType, iceP_query, iceP_divtypes, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_divtypes);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneDivType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    IDivTypeValue iceP_divtype;
    bool ret = this->GetOneDivType(iceP_codeId, iceP_timeType, iceP_timePos, iceP_divtype, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_divtype);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountAvgAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RecountAvgAtr(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RecountAvgAtrFromTimePos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    this->RecountAvgAtrFromTimePos(iceP_codeId, iceP_timeType, iceP_timePos, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_UpdateAvgAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Double iceP_avgAtr;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_avgAtr);
    inS.endReadParams();
    this->UpdateAvgAtr(iceP_codeId, iceP_timeType, iceP_avgAtr, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAllAvgAtrs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    inS.endReadParams();
    this->RemoveAllAvgAtrs(iceP_codeId, iceP_timeType, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_RemoveAvgAtrsByRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_beginTime;
    ::Ice::Long iceP_endTime;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_beginTime);
    istr->read(iceP_endTime);
    inS.endReadParams();
    this->RemoveAvgAtrsByRange(iceP_codeId, iceP_timeType, iceP_beginTime, iceP_endTime, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetAvgAtrs(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    IQuery iceP_query;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_query);
    inS.endReadParams();
    IAvgAtrs iceP_avgAtrs;
    this->GetAvgAtrs(iceP_codeId, iceP_timeType, iceP_query, iceP_avgAtrs, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_avgAtrs);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceD_GetOneAvgAtr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_codeId;
    ITimeType iceP_timeType;
    ::Ice::Long iceP_timePos;
    istr->read(iceP_codeId);
    istr->read(iceP_timeType);
    istr->read(iceP_timePos);
    inS.endReadParams();
    ::Ice::Double iceP_avgAtr;
    bool ret = this->GetOneAvgAtr(iceP_codeId, iceP_timeType, iceP_timePos, iceP_avgAtr, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_avgAtr);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_IBTrader_IQDatabase_all[] =
{
    "GetAvgAtrs",
    "GetDivTypes",
    "GetEmas",
    "GetInvalidKLines",
    "GetKLinePairs",
    "GetKLines",
    "GetLastUpdateTick",
    "GetMacds",
    "GetMas",
    "GetOneAvgAtr",
    "GetOneDivType",
    "GetOneEma",
    "GetOneKLine",
    "GetOneMa",
    "GetOneMacd",
    "GetOneTick",
    "GetOneVwMa",
    "GetTicks",
    "GetVwMas",
    "RecountAvgAtr",
    "RecountAvgAtrFromTimePos",
    "RecountDivType",
    "RecountDivTypeFromTimePos",
    "RecountEma",
    "RecountEmaFromTimePos",
    "RecountMa",
    "RecountMaFromTimePos",
    "RecountMacd",
    "RecountMacdFromTimePos",
    "RecountVwMa",
    "RecountVwMaFromTimePos",
    "RemoveAllAvgAtrs",
    "RemoveAllDivTypes",
    "RemoveAllEmas",
    "RemoveAllKLines",
    "RemoveAllMacds",
    "RemoveAllMas",
    "RemoveAllTicks",
    "RemoveAllVwMas",
    "RemoveAvgAtrsByRange",
    "RemoveDivTypesByRange",
    "RemoveEmasByRange",
    "RemoveKLinesByRange",
    "RemoveMacdsByRange",
    "RemoveMasByRange",
    "RemoveOneKLine",
    "RemoveTicksByRange",
    "RemoveVwMasByRange",
    "UpdateAvgAtr",
    "UpdateDivType",
    "UpdateEma",
    "UpdateKLine",
    "UpdateMa",
    "UpdateMacd",
    "UpdateTickToDB",
    "UpdateVwMa",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
IBTrader::IQDatabase::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IBTrader_IQDatabase_all, iceC_IBTrader_IQDatabase_all + 60, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IBTrader_IQDatabase_all)
    {
        case 0:
        {
            return _iceD_GetAvgAtrs(in, current);
        }
        case 1:
        {
            return _iceD_GetDivTypes(in, current);
        }
        case 2:
        {
            return _iceD_GetEmas(in, current);
        }
        case 3:
        {
            return _iceD_GetInvalidKLines(in, current);
        }
        case 4:
        {
            return _iceD_GetKLinePairs(in, current);
        }
        case 5:
        {
            return _iceD_GetKLines(in, current);
        }
        case 6:
        {
            return _iceD_GetLastUpdateTick(in, current);
        }
        case 7:
        {
            return _iceD_GetMacds(in, current);
        }
        case 8:
        {
            return _iceD_GetMas(in, current);
        }
        case 9:
        {
            return _iceD_GetOneAvgAtr(in, current);
        }
        case 10:
        {
            return _iceD_GetOneDivType(in, current);
        }
        case 11:
        {
            return _iceD_GetOneEma(in, current);
        }
        case 12:
        {
            return _iceD_GetOneKLine(in, current);
        }
        case 13:
        {
            return _iceD_GetOneMa(in, current);
        }
        case 14:
        {
            return _iceD_GetOneMacd(in, current);
        }
        case 15:
        {
            return _iceD_GetOneTick(in, current);
        }
        case 16:
        {
            return _iceD_GetOneVwMa(in, current);
        }
        case 17:
        {
            return _iceD_GetTicks(in, current);
        }
        case 18:
        {
            return _iceD_GetVwMas(in, current);
        }
        case 19:
        {
            return _iceD_RecountAvgAtr(in, current);
        }
        case 20:
        {
            return _iceD_RecountAvgAtrFromTimePos(in, current);
        }
        case 21:
        {
            return _iceD_RecountDivType(in, current);
        }
        case 22:
        {
            return _iceD_RecountDivTypeFromTimePos(in, current);
        }
        case 23:
        {
            return _iceD_RecountEma(in, current);
        }
        case 24:
        {
            return _iceD_RecountEmaFromTimePos(in, current);
        }
        case 25:
        {
            return _iceD_RecountMa(in, current);
        }
        case 26:
        {
            return _iceD_RecountMaFromTimePos(in, current);
        }
        case 27:
        {
            return _iceD_RecountMacd(in, current);
        }
        case 28:
        {
            return _iceD_RecountMacdFromTimePos(in, current);
        }
        case 29:
        {
            return _iceD_RecountVwMa(in, current);
        }
        case 30:
        {
            return _iceD_RecountVwMaFromTimePos(in, current);
        }
        case 31:
        {
            return _iceD_RemoveAllAvgAtrs(in, current);
        }
        case 32:
        {
            return _iceD_RemoveAllDivTypes(in, current);
        }
        case 33:
        {
            return _iceD_RemoveAllEmas(in, current);
        }
        case 34:
        {
            return _iceD_RemoveAllKLines(in, current);
        }
        case 35:
        {
            return _iceD_RemoveAllMacds(in, current);
        }
        case 36:
        {
            return _iceD_RemoveAllMas(in, current);
        }
        case 37:
        {
            return _iceD_RemoveAllTicks(in, current);
        }
        case 38:
        {
            return _iceD_RemoveAllVwMas(in, current);
        }
        case 39:
        {
            return _iceD_RemoveAvgAtrsByRange(in, current);
        }
        case 40:
        {
            return _iceD_RemoveDivTypesByRange(in, current);
        }
        case 41:
        {
            return _iceD_RemoveEmasByRange(in, current);
        }
        case 42:
        {
            return _iceD_RemoveKLinesByRange(in, current);
        }
        case 43:
        {
            return _iceD_RemoveMacdsByRange(in, current);
        }
        case 44:
        {
            return _iceD_RemoveMasByRange(in, current);
        }
        case 45:
        {
            return _iceD_RemoveOneKLine(in, current);
        }
        case 46:
        {
            return _iceD_RemoveTicksByRange(in, current);
        }
        case 47:
        {
            return _iceD_RemoveVwMasByRange(in, current);
        }
        case 48:
        {
            return _iceD_UpdateAvgAtr(in, current);
        }
        case 49:
        {
            return _iceD_UpdateDivType(in, current);
        }
        case 50:
        {
            return _iceD_UpdateEma(in, current);
        }
        case 51:
        {
            return _iceD_UpdateKLine(in, current);
        }
        case 52:
        {
            return _iceD_UpdateMa(in, current);
        }
        case 53:
        {
            return _iceD_UpdateMacd(in, current);
        }
        case 54:
        {
            return _iceD_UpdateTickToDB(in, current);
        }
        case 55:
        {
            return _iceD_UpdateVwMa(in, current);
        }
        case 56:
        {
            return _iceD_ice_id(in, current);
        }
        case 57:
        {
            return _iceD_ice_ids(in, current);
        }
        case 58:
        {
            return _iceD_ice_isA(in, current);
        }
        case 59:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
IBTrader::IQDatabase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< IQDatabase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
IBTrader::IQDatabase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< IQDatabase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
IBTrader::_icePatchObjectPtr(IQDatabasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = IQDatabasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(IQDatabase::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
