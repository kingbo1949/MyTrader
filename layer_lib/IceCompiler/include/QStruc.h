//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `QStruc.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __QStruc_h__
#define __QStruc_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace IBTrader
{

enum class IExchangePl : unsigned char
{
    SMART,
    SEHK,
    NYSE,
    NASDAQ,
    ARCA
};

enum class IMoney : unsigned char
{
    RMB,
    USD,
    HKD,
    GBP,
    JPY,
    CAD,
    AUD,
    EUR,
    KRW
};

struct ITimePair
{
    long long int beginPos = 0LL;
    long long int endPos = 0LL;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&, const long long int&> ice_tuple() const
    {
        return std::tie(beginPos, endPos);
    }
};

using ITimePairs = ::std::vector<ITimePair>;

struct IQuery
{
    ::Ice::Byte byReqType = 0;
    long long int dwSubscribeNum = 0LL;
    long long int tTime = 0LL;
    ::IBTrader::ITimePair timePair;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Byte&, const long long int&, const long long int&, const ::IBTrader::ITimePair&> ice_tuple() const
    {
        return std::tie(byReqType, dwSubscribeNum, tTime, timePair);
    }
};

struct IContract
{
    ::std::string codeId;
    ::std::string des;
    ::IBTrader::IExchangePl exchangePl = ::IBTrader::IExchangePl::SMART;
    ::IBTrader::IExchangePl primaryExchangePl = ::IBTrader::IExchangePl::NASDAQ;
    ::IBTrader::IMoney currencyID = ::IBTrader::IMoney::USD;
    int decDigits = 0;
    double minMove = 0;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::IBTrader::IExchangePl&, const ::IBTrader::IExchangePl&, const ::IBTrader::IMoney&, const int&, const double&> ice_tuple() const
    {
        return std::tie(codeId, des, exchangePl, primaryExchangePl, currencyID, decDigits, minMove);
    }
};

using IContracts = ::std::vector<IContract>;

struct IBidAsk
{
    double bid = 0;
    int bidVol = 0;
    double ask = 0;
    int askVol = 0;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const double&, const int&, const double&, const int&> ice_tuple() const
    {
        return std::tie(bid, bidVol, ask, askVol);
    }
};

using IBidAsks = ::std::vector<IBidAsk>;

struct ITick
{
    ::std::string codeId;
    long long int time = 0LL;
    ::IBTrader::IBidAsks bidAsks;
    double open = 0;
    double last = 0;
    int vol = 0;
    int totalVol = 0;
    double turnOver = 0;
    long long int timeStamp = 0LL;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const long long int&, const ::IBTrader::IBidAsks&, const double&, const double&, const int&, const int&, const double&, const long long int&> ice_tuple() const
    {
        return std::tie(codeId, time, bidAsks, open, last, vol, totalVol, turnOver, timeStamp);
    }
};

using ITicks = ::std::vector<ITick>;

enum class ITimeType : unsigned char
{
    S15,
    M1,
    M5,
    M15,
    M30,
    H1,
    D1
};

struct IQKey
{
    ::std::string codeId;
    ::IBTrader::ITimeType timeType = ::IBTrader::ITimeType::D1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IBTrader::ITimeType&> ice_tuple() const
    {
        return std::tie(codeId, timeType);
    }
};

struct IKLine
{
    long long int time;
    double close;
    double open;
    double high;
    double low;
    long long int vol;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&, const double&, const double&, const double&, const double&, const long long int&> ice_tuple() const
    {
        return std::tie(time, close, open, high, low, vol);
    }
};

using IKLines = ::std::vector<IKLine>;

struct IKLinePair
{
    ::IBTrader::IKLine first;
    ::IBTrader::IKLine second;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IBTrader::IKLine&, const ::IBTrader::IKLine&> ice_tuple() const
    {
        return std::tie(first, second);
    }
};

using IKLinePairs = ::std::vector<IKLinePair>;

struct IAvgValue
{
    long long int time;
    double v5;
    double v20;
    double v60;
    double v200;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&, const double&, const double&, const double&, const double&> ice_tuple() const
    {
        return std::tie(time, v5, v20, v60, v200);
    }
};

using IAvgValues = ::std::vector<IAvgValue>;

struct IMacdValue
{
    long long int time;
    double emaShort;
    double emaLong;
    double dif;
    double dea;
    double macd;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&, const double&, const double&, const double&, const double&, const double&> ice_tuple() const
    {
        return std::tie(time, emaShort, emaLong, dif, dea, macd);
    }
};

using IMacdValues = ::std::vector<IMacdValue>;

enum class IDivType : unsigned char
{
    NORMAL,
    TOP,
    BOTTOM,
    TOPSUB,
    BOTTOMSUB
};

using IDivTypes = ::std::vector<IDivType>;

struct IDivTypeValue
{
    long long int time = 0LL;
    ::IBTrader::IDivType divType = ::IBTrader::IDivType::NORMAL;
    bool isUTurn = false;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&, const ::IBTrader::IDivType&, const bool&> ice_tuple() const
    {
        return std::tie(time, divType, isUTurn);
    }
};

using IDivTypeValues = ::std::vector<IDivTypeValue>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::IBTrader::IExchangePl>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::IBTrader::IMoney>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 8;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::IBTrader::ITimePair>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::ITimePair, S>
{
    static void read(S* istr, ::IBTrader::ITimePair& v)
    {
        istr->readAll(v.beginPos, v.endPos);
    }
};

template<>
struct StreamableTraits<::IBTrader::IQuery>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 33;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::IQuery, S>
{
    static void read(S* istr, ::IBTrader::IQuery& v)
    {
        istr->readAll(v.byReqType, v.dwSubscribeNum, v.tTime, v.timePair);
    }
};

template<>
struct StreamableTraits<::IBTrader::IContract>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 17;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IBTrader::IContract, S>
{
    static void read(S* istr, ::IBTrader::IContract& v)
    {
        istr->readAll(v.codeId, v.des, v.exchangePl, v.primaryExchangePl, v.currencyID, v.decDigits, v.minMove);
    }
};

template<>
struct StreamableTraits<::IBTrader::IBidAsk>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::IBidAsk, S>
{
    static void read(S* istr, ::IBTrader::IBidAsk& v)
    {
        istr->readAll(v.bid, v.bidVol, v.ask, v.askVol);
    }
};

template<>
struct StreamableTraits<::IBTrader::ITick>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 50;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IBTrader::ITick, S>
{
    static void read(S* istr, ::IBTrader::ITick& v)
    {
        istr->readAll(v.codeId, v.time, v.bidAsks, v.open, v.last, v.vol, v.totalVol, v.turnOver, v.timeStamp);
    }
};

template<>
struct StreamableTraits< ::IBTrader::ITimeType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::IBTrader::IQKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IBTrader::IQKey, S>
{
    static void read(S* istr, ::IBTrader::IQKey& v)
    {
        istr->readAll(v.codeId, v.timeType);
    }
};

template<>
struct StreamableTraits<::IBTrader::IKLine>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 48;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::IKLine, S>
{
    static void read(S* istr, ::IBTrader::IKLine& v)
    {
        istr->readAll(v.time, v.close, v.open, v.high, v.low, v.vol);
    }
};

template<>
struct StreamableTraits<::IBTrader::IKLinePair>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 96;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::IKLinePair, S>
{
    static void read(S* istr, ::IBTrader::IKLinePair& v)
    {
        istr->readAll(v.first, v.second);
    }
};

template<>
struct StreamableTraits<::IBTrader::IAvgValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 40;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::IAvgValue, S>
{
    static void read(S* istr, ::IBTrader::IAvgValue& v)
    {
        istr->readAll(v.time, v.v5, v.v20, v.v60, v.v200);
    }
};

template<>
struct StreamableTraits<::IBTrader::IMacdValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 48;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::IBTrader::IMacdValue, S>
{
    static void read(S* istr, ::IBTrader::IMacdValue& v)
    {
        istr->readAll(v.time, v.emaShort, v.emaLong, v.dif, v.dea, v.macd);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IDivType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::IBTrader::IDivTypeValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IBTrader::IDivTypeValue, S>
{
    static void read(S* istr, ::IBTrader::IDivTypeValue& v)
    {
        istr->readAll(v.time, v.divType, v.isUTurn);
    }
};

}
/// \endcond

#else // C++98 mapping

namespace IBTrader
{

enum IExchangePl
{
    SMART,
    SEHK,
    NYSE,
    NASDAQ,
    ARCA
};

enum IMoney
{
    RMB,
    USD,
    HKD,
    GBP,
    JPY,
    CAD,
    AUD,
    EUR,
    KRW
};

struct ITimePair
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    ITimePair() :
        beginPos(ICE_INT64(0)),
        endPos(ICE_INT64(0))
    {
    }
    
    ITimePair(::Ice::Long beginPos, ::Ice::Long endPos) :
        beginPos(beginPos),
        endPos(endPos)
    {
    }
    

    ::Ice::Long beginPos;
    ::Ice::Long endPos;

    bool operator==(const ITimePair& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(beginPos != rhs_.beginPos)
        {
            return false;
        }
        if(endPos != rhs_.endPos)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ITimePair& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(beginPos < rhs_.beginPos)
        {
            return true;
        }
        else if(rhs_.beginPos < beginPos)
        {
            return false;
        }
        if(endPos < rhs_.endPos)
        {
            return true;
        }
        else if(rhs_.endPos < endPos)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ITimePair& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ITimePair& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ITimePair& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ITimePair& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ITimePair> ITimePairs;

struct IQuery
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    IQuery() :
        byReqType(0),
        dwSubscribeNum(ICE_INT64(0)),
        tTime(ICE_INT64(0))
    {
    }
    
    IQuery(::Ice::Byte byReqType, ::Ice::Long dwSubscribeNum, ::Ice::Long tTime, const ITimePair& timePair) :
        byReqType(byReqType),
        dwSubscribeNum(dwSubscribeNum),
        tTime(tTime),
        timePair(timePair)
    {
    }
    

    ::Ice::Byte byReqType;
    ::Ice::Long dwSubscribeNum;
    ::Ice::Long tTime;
    ::IBTrader::ITimePair timePair;

    bool operator==(const IQuery& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(byReqType != rhs_.byReqType)
        {
            return false;
        }
        if(dwSubscribeNum != rhs_.dwSubscribeNum)
        {
            return false;
        }
        if(tTime != rhs_.tTime)
        {
            return false;
        }
        if(timePair != rhs_.timePair)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IQuery& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(byReqType < rhs_.byReqType)
        {
            return true;
        }
        else if(rhs_.byReqType < byReqType)
        {
            return false;
        }
        if(dwSubscribeNum < rhs_.dwSubscribeNum)
        {
            return true;
        }
        else if(rhs_.dwSubscribeNum < dwSubscribeNum)
        {
            return false;
        }
        if(tTime < rhs_.tTime)
        {
            return true;
        }
        else if(rhs_.tTime < tTime)
        {
            return false;
        }
        if(timePair < rhs_.timePair)
        {
            return true;
        }
        else if(rhs_.timePair < timePair)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IQuery& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const IQuery& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const IQuery& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const IQuery& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct IContract
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    IContract() :
        codeId(""),
        des(""),
        exchangePl(SMART),
        primaryExchangePl(NASDAQ),
        currencyID(USD),
        decDigits(0),
        minMove(0)
    {
    }
    
    IContract(const ::std::string& codeId, const ::std::string& des, IExchangePl exchangePl, IExchangePl primaryExchangePl, IMoney currencyID, ::Ice::Int decDigits, ::Ice::Double minMove) :
        codeId(codeId),
        des(des),
        exchangePl(exchangePl),
        primaryExchangePl(primaryExchangePl),
        currencyID(currencyID),
        decDigits(decDigits),
        minMove(minMove)
    {
    }
    

    ::std::string codeId;
    ::std::string des;
    ::IBTrader::IExchangePl exchangePl;
    ::IBTrader::IExchangePl primaryExchangePl;
    ::IBTrader::IMoney currencyID;
    ::Ice::Int decDigits;
    ::Ice::Double minMove;
};

typedef ::std::vector<IContract> IContracts;

struct IBidAsk
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    IBidAsk() :
        bid(0),
        bidVol(0),
        ask(0),
        askVol(0)
    {
    }
    
    IBidAsk(::Ice::Double bid, ::Ice::Int bidVol, ::Ice::Double ask, ::Ice::Int askVol) :
        bid(bid),
        bidVol(bidVol),
        ask(ask),
        askVol(askVol)
    {
    }
    

    ::Ice::Double bid;
    ::Ice::Int bidVol;
    ::Ice::Double ask;
    ::Ice::Int askVol;
};

typedef ::std::vector<IBidAsk> IBidAsks;

struct ITick
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    ITick() :
        codeId(""),
        time(ICE_INT64(0)),
        open(0),
        last(0),
        vol(0),
        totalVol(0),
        turnOver(0),
        timeStamp(ICE_INT64(0))
    {
    }
    
    ITick(const ::std::string& codeId, ::Ice::Long time, const IBidAsks& bidAsks, ::Ice::Double open, ::Ice::Double last, ::Ice::Int vol, ::Ice::Int totalVol, ::Ice::Double turnOver, ::Ice::Long timeStamp) :
        codeId(codeId),
        time(time),
        bidAsks(bidAsks),
        open(open),
        last(last),
        vol(vol),
        totalVol(totalVol),
        turnOver(turnOver),
        timeStamp(timeStamp)
    {
    }
    

    ::std::string codeId;
    ::Ice::Long time;
    ::IBTrader::IBidAsks bidAsks;
    ::Ice::Double open;
    ::Ice::Double last;
    ::Ice::Int vol;
    ::Ice::Int totalVol;
    ::Ice::Double turnOver;
    ::Ice::Long timeStamp;
};

typedef ::std::vector<ITick> ITicks;

enum ITimeType
{
    S15,
    M1,
    M5,
    M15,
    M30,
    H1,
    D1
};

struct IQKey
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    IQKey() :
        codeId(""),
        timeType(D1)
    {
    }
    
    IQKey(const ::std::string& codeId, ITimeType timeType) :
        codeId(codeId),
        timeType(timeType)
    {
    }
    

    ::std::string codeId;
    ::IBTrader::ITimeType timeType;

    bool operator==(const IQKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(codeId != rhs_.codeId)
        {
            return false;
        }
        if(timeType != rhs_.timeType)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IQKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(codeId < rhs_.codeId)
        {
            return true;
        }
        else if(rhs_.codeId < codeId)
        {
            return false;
        }
        if(timeType < rhs_.timeType)
        {
            return true;
        }
        else if(rhs_.timeType < timeType)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IQKey& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const IQKey& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const IQKey& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const IQKey& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct IKLine
{
    ::Ice::Long time;
    ::Ice::Double close;
    ::Ice::Double open;
    ::Ice::Double high;
    ::Ice::Double low;
    ::Ice::Long vol;
};

typedef ::std::vector<IKLine> IKLines;

struct IKLinePair
{
    ::IBTrader::IKLine first;
    ::IBTrader::IKLine second;
};

typedef ::std::vector<IKLinePair> IKLinePairs;

struct IAvgValue
{
    ::Ice::Long time;
    ::Ice::Double v5;
    ::Ice::Double v20;
    ::Ice::Double v60;
    ::Ice::Double v200;
};

typedef ::std::vector<IAvgValue> IAvgValues;

struct IMacdValue
{
    ::Ice::Long time;
    ::Ice::Double emaShort;
    ::Ice::Double emaLong;
    ::Ice::Double dif;
    ::Ice::Double dea;
    ::Ice::Double macd;
};

typedef ::std::vector<IMacdValue> IMacdValues;

enum IDivType
{
    NORMAL,
    TOP,
    BOTTOM,
    TOPSUB,
    BOTTOMSUB
};

typedef ::std::vector<IDivType> IDivTypes;

struct IDivTypeValue
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    IDivTypeValue() :
        time(ICE_INT64(0)),
        divType(NORMAL),
        isUTurn(false)
    {
    }
    
    IDivTypeValue(::Ice::Long time, IDivType divType, bool isUTurn) :
        time(time),
        divType(divType),
        isUTurn(isUTurn)
    {
    }
    

    ::Ice::Long time;
    ::IBTrader::IDivType divType;
    bool isUTurn;

    bool operator==(const IDivTypeValue& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(divType != rhs_.divType)
        {
            return false;
        }
        if(isUTurn != rhs_.isUTurn)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IDivTypeValue& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(divType < rhs_.divType)
        {
            return true;
        }
        else if(rhs_.divType < divType)
        {
            return false;
        }
        if(isUTurn < rhs_.isUTurn)
        {
            return true;
        }
        else if(rhs_.isUTurn < isUTurn)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IDivTypeValue& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const IDivTypeValue& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const IDivTypeValue& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const IDivTypeValue& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<IDivTypeValue> IDivTypeValues;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::IBTrader::IExchangePl>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::IBTrader::IMoney>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 8;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::IBTrader::ITimePair>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::ITimePair, S>
{
    static void write(S* ostr, const ::IBTrader::ITimePair& v)
    {
        ostr->write(v.beginPos);
        ostr->write(v.endPos);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::ITimePair, S>
{
    static void read(S* istr, ::IBTrader::ITimePair& v)
    {
        istr->read(v.beginPos);
        istr->read(v.endPos);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IQuery>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 33;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::IQuery, S>
{
    static void write(S* ostr, const ::IBTrader::IQuery& v)
    {
        ostr->write(v.byReqType);
        ostr->write(v.dwSubscribeNum);
        ostr->write(v.tTime);
        ostr->write(v.timePair);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IQuery, S>
{
    static void read(S* istr, ::IBTrader::IQuery& v)
    {
        istr->read(v.byReqType);
        istr->read(v.dwSubscribeNum);
        istr->read(v.tTime);
        istr->read(v.timePair);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IContract>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 17;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::IBTrader::IContract, S>
{
    static void write(S* ostr, const ::IBTrader::IContract& v)
    {
        ostr->write(v.codeId);
        ostr->write(v.des);
        ostr->write(v.exchangePl);
        ostr->write(v.primaryExchangePl);
        ostr->write(v.currencyID);
        ostr->write(v.decDigits);
        ostr->write(v.minMove);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IContract, S>
{
    static void read(S* istr, ::IBTrader::IContract& v)
    {
        istr->read(v.codeId);
        istr->read(v.des);
        istr->read(v.exchangePl);
        istr->read(v.primaryExchangePl);
        istr->read(v.currencyID);
        istr->read(v.decDigits);
        istr->read(v.minMove);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IBidAsk>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::IBidAsk, S>
{
    static void write(S* ostr, const ::IBTrader::IBidAsk& v)
    {
        ostr->write(v.bid);
        ostr->write(v.bidVol);
        ostr->write(v.ask);
        ostr->write(v.askVol);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IBidAsk, S>
{
    static void read(S* istr, ::IBTrader::IBidAsk& v)
    {
        istr->read(v.bid);
        istr->read(v.bidVol);
        istr->read(v.ask);
        istr->read(v.askVol);
    }
};

template<>
struct StreamableTraits< ::IBTrader::ITick>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 50;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::IBTrader::ITick, S>
{
    static void write(S* ostr, const ::IBTrader::ITick& v)
    {
        ostr->write(v.codeId);
        ostr->write(v.time);
        ostr->write(v.bidAsks);
        ostr->write(v.open);
        ostr->write(v.last);
        ostr->write(v.vol);
        ostr->write(v.totalVol);
        ostr->write(v.turnOver);
        ostr->write(v.timeStamp);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::ITick, S>
{
    static void read(S* istr, ::IBTrader::ITick& v)
    {
        istr->read(v.codeId);
        istr->read(v.time);
        istr->read(v.bidAsks);
        istr->read(v.open);
        istr->read(v.last);
        istr->read(v.vol);
        istr->read(v.totalVol);
        istr->read(v.turnOver);
        istr->read(v.timeStamp);
    }
};

template<>
struct StreamableTraits< ::IBTrader::ITimeType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::IBTrader::IQKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::IBTrader::IQKey, S>
{
    static void write(S* ostr, const ::IBTrader::IQKey& v)
    {
        ostr->write(v.codeId);
        ostr->write(v.timeType);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IQKey, S>
{
    static void read(S* istr, ::IBTrader::IQKey& v)
    {
        istr->read(v.codeId);
        istr->read(v.timeType);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IKLine>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 48;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::IKLine, S>
{
    static void write(S* ostr, const ::IBTrader::IKLine& v)
    {
        ostr->write(v.time);
        ostr->write(v.close);
        ostr->write(v.open);
        ostr->write(v.high);
        ostr->write(v.low);
        ostr->write(v.vol);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IKLine, S>
{
    static void read(S* istr, ::IBTrader::IKLine& v)
    {
        istr->read(v.time);
        istr->read(v.close);
        istr->read(v.open);
        istr->read(v.high);
        istr->read(v.low);
        istr->read(v.vol);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IKLinePair>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 96;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::IKLinePair, S>
{
    static void write(S* ostr, const ::IBTrader::IKLinePair& v)
    {
        ostr->write(v.first);
        ostr->write(v.second);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IKLinePair, S>
{
    static void read(S* istr, ::IBTrader::IKLinePair& v)
    {
        istr->read(v.first);
        istr->read(v.second);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IAvgValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 40;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::IAvgValue, S>
{
    static void write(S* ostr, const ::IBTrader::IAvgValue& v)
    {
        ostr->write(v.time);
        ostr->write(v.v5);
        ostr->write(v.v20);
        ostr->write(v.v60);
        ostr->write(v.v200);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IAvgValue, S>
{
    static void read(S* istr, ::IBTrader::IAvgValue& v)
    {
        istr->read(v.time);
        istr->read(v.v5);
        istr->read(v.v20);
        istr->read(v.v60);
        istr->read(v.v200);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IMacdValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 48;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::IBTrader::IMacdValue, S>
{
    static void write(S* ostr, const ::IBTrader::IMacdValue& v)
    {
        ostr->write(v.time);
        ostr->write(v.emaShort);
        ostr->write(v.emaLong);
        ostr->write(v.dif);
        ostr->write(v.dea);
        ostr->write(v.macd);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IMacdValue, S>
{
    static void read(S* istr, ::IBTrader::IMacdValue& v)
    {
        istr->read(v.time);
        istr->read(v.emaShort);
        istr->read(v.emaLong);
        istr->read(v.dif);
        istr->read(v.dea);
        istr->read(v.macd);
    }
};

template<>
struct StreamableTraits< ::IBTrader::IDivType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::IBTrader::IDivTypeValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::IBTrader::IDivTypeValue, S>
{
    static void write(S* ostr, const ::IBTrader::IDivTypeValue& v)
    {
        ostr->write(v.time);
        ostr->write(v.divType);
        ostr->write(v.isUTurn);
    }
};

template<typename S>
struct StreamReader< ::IBTrader::IDivTypeValue, S>
{
    static void read(S* istr, ::IBTrader::IDivTypeValue& v)
    {
        istr->read(v.time);
        istr->read(v.divType);
        istr->read(v.isUTurn);
    }
};

}
/// \endcond

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
