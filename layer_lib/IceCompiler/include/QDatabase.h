//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `QDatabase.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __QDatabase_h__
#define __QDatabase_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <QStruc.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace IBTrader
{

class IQDatabase;
class IQDatabasePrx;

}

namespace IBTrader
{

class IQDatabase : public virtual ::Ice::Object
{
public:

    using ProxyType = IQDatabasePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void UpdateTickToDB(ITick tick, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTickToDB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetLastUpdateTick.
     */
    struct GetLastUpdateTickResult
    {
        ITick returnValue;
        int updateCount;
        long long int recentUpdateSecnd;
    };

    virtual ITick GetLastUpdateTick(int& updateCount, long long int& recentUpdateSecnd, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLastUpdateTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllTicks(::std::string codeId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveTicksByRange(::std::string codeId, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveTicksByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetTicks(::std::string codeId, IQuery query, ITicks& ticks, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneTick.
     */
    struct GetOneTickResult
    {
        bool returnValue;
        ITick tick;
    };

    virtual bool GetOneTick(::std::string codeId, long long int timePos, ITick& tick, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateKLine(::std::string codeId, ITimeType timeType, IKLine kline, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllKLines(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveKLinesByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveKLinesByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveOneKLine(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLines(::std::string codeId, ITimeType timeType, IQuery query, IKLines& klines, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneKLine.
     */
    struct GetOneKLineResult
    {
        bool returnValue;
        IKLine kline;
    };

    virtual bool GetOneKLine(::std::string codeId, ITimeType timeType, long long int timePos, IKLine& kline, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLinePairs(::std::string first, ::std::string second, ITimeType timeType, IQuery query, IKLinePairs& kLinePairs, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLinePairs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetInvalidKLines(::std::string codeId, ITimeType timeType, IKLines& klines, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetInvalidKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMa(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMaFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMaFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateMa(::std::string codeId, ITimeType timeType, IAvgValue ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllMas(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveMasByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveMasByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMas(::std::string codeId, ITimeType timeType, IQuery query, IAvgValues& mas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneMa.
     */
    struct GetOneMaResult
    {
        bool returnValue;
        IAvgValue ma;
    };

    virtual bool GetOneMa(::std::string codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountVwMa(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountVwMaFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountVwMaFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateVwMa(::std::string codeId, ITimeType timeType, IAvgValue ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllVwMas(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllVwMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveVwMasByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveVwMasByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetVwMas(::std::string codeId, ITimeType timeType, IQuery query, IAvgValues& mas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVwMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneVwMa.
     */
    struct GetOneVwMaResult
    {
        bool returnValue;
        IAvgValue ma;
    };

    virtual bool GetOneVwMa(::std::string codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountEma(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountEmaFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountEmaFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateEma(::std::string codeId, ITimeType timeType, IAvgValue ema, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllEmas(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllEmas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveEmasByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveEmasByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetEmas(::std::string codeId, ITimeType timeType, IQuery query, IAvgValues& emas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetEmas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneEma.
     */
    struct GetOneEmaResult
    {
        bool returnValue;
        IAvgValue ema;
    };

    virtual bool GetOneEma(::std::string codeId, ITimeType timeType, long long int timePos, IAvgValue& ema, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMacd(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMacdFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMacdFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateMacd(::std::string codeId, ITimeType timeType, IMacdValue macd, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllMacds(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllMacds(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveMacdsByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveMacdsByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMacds(::std::string codeId, ITimeType timeType, IQuery query, IMacdValues& macds, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMacds(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneMacd.
     */
    struct GetOneMacdResult
    {
        bool returnValue;
        IMacdValue ma;
    };

    virtual bool GetOneMacd(::std::string codeId, ITimeType timeType, long long int timePos, IMacdValue& ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountDivType(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountDivTypeFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountDivTypeFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateDivType(::std::string codeId, ITimeType timeType, IDivTypeValue divtype, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllDivTypes(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllDivTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveDivTypesByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveDivTypesByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetDivTypes(::std::string codeId, ITimeType timeType, IQuery query, IDivTypeValues& divtypes, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetDivTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneDivType.
     */
    struct GetOneDivTypeResult
    {
        bool returnValue;
        IDivTypeValue divtype;
    };

    virtual bool GetOneDivType(::std::string codeId, ITimeType timeType, long long int timePos, IDivTypeValue& divtype, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountAtr(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountAtrFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountAtrFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateAtr(::std::string codeId, ITimeType timeType, IAtrValue artValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllAtrs(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllAtrs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAtrsByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAtrsByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetAtrs(::std::string codeId, ITimeType timeType, IQuery query, IAtrValues& avgAtrs, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAtrs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneAtr.
     */
    struct GetOneAtrResult
    {
        bool returnValue;
        IAtrValue avgAtr;
    };

    virtual bool GetOneAtr(::std::string codeId, ITimeType timeType, long long int timePos, IAtrValue& avgAtr, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace IBTrader
{

class IQDatabasePrx : public virtual ::Ice::Proxy<IQDatabasePrx, ::Ice::ObjectPrx>
{
public:

    void UpdateTickToDB(const ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateTickToDB, tick, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateTickToDBAsync(const ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateTickToDB, tick, context);
    }

    ::std::function<void()>
    UpdateTickToDBAsync(const ITick& tick,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateTickToDB, tick, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateTickToDB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ITick&, const ::Ice::Context&);
    /// \endcond

    ITick GetLastUpdateTick(int& updateCount, long long int& recentUpdateSecnd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetLastUpdateTickResult>(true, this, &IQDatabasePrx::_iceI_GetLastUpdateTick, context).get();
        updateCount = _result.updateCount;
        recentUpdateSecnd = _result.recentUpdateSecnd;
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto GetLastUpdateTickAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetLastUpdateTickResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetLastUpdateTickResult, P>(false, this, &IQDatabasePrx::_iceI_GetLastUpdateTick, context);
    }

    ::std::function<void()>
    GetLastUpdateTickAsync(::std::function<void(::IBTrader::ITick, int, long long int)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetLastUpdateTickResult&& _result)
        {
            response(::std::move(_result.returnValue), _result.updateCount, _result.recentUpdateSecnd);
        };
        return _makeLamdaOutgoing<IQDatabase::GetLastUpdateTickResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetLastUpdateTick, context);
    }

    /// \cond INTERNAL
    void _iceI_GetLastUpdateTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetLastUpdateTickResult>>&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllTicks, codeId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllTicksAsync(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllTicks, codeId, context);
    }

    ::std::function<void()>
    RemoveAllTicksAsync(const ::std::string& codeId,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllTicks, codeId, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void RemoveTicksByRange(const ::std::string& codeId, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveTicksByRange, codeId, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveTicksByRangeAsync(const ::std::string& codeId, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveTicksByRange, codeId, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveTicksByRangeAsync(const ::std::string& codeId, long long int beginTime, long long int endTime,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveTicksByRange, codeId, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveTicksByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetTicks(const ::std::string& codeId, const IQuery& query, ITicks& ticks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        ticks = _makePromiseOutgoing<::IBTrader::ITicks>(true, this, &IQDatabasePrx::_iceI_GetTicks, codeId, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetTicksAsync(const ::std::string& codeId, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::ITicks>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::ITicks, P>(false, this, &IQDatabasePrx::_iceI_GetTicks, codeId, query, context);
    }

    ::std::function<void()>
    GetTicksAsync(const ::std::string& codeId, const IQuery& query,
                  ::std::function<void(::IBTrader::ITicks)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::ITicks>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetTicks, codeId, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::ITicks>>&, const ::std::string&, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneTick(const ::std::string& codeId, long long int timePos, ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneTickResult>(true, this, &IQDatabasePrx::_iceI_GetOneTick, codeId, timePos, context).get();
        tick = ::std::move(_result.tick);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneTickAsync(const ::std::string& codeId, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneTickResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneTickResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneTick, codeId, timePos, context);
    }

    ::std::function<void()>
    GetOneTickAsync(const ::std::string& codeId, long long int timePos,
                    ::std::function<void(bool, ::IBTrader::ITick)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneTickResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.tick));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneTickResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneTick, codeId, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneTickResult>>&, const ::std::string&, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateKLine(const ::std::string& codeId, ITimeType timeType, const IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateKLine, codeId, timeType, kline, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateKLineAsync(const ::std::string& codeId, ITimeType timeType, const IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateKLine, codeId, timeType, kline, context);
    }

    ::std::function<void()>
    UpdateKLineAsync(const ::std::string& codeId, ITimeType timeType, const IKLine& kline,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateKLine, codeId, timeType, kline, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IKLine&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllKLines(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllKLines, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllKLinesAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllKLines, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllKLinesAsync(const ::std::string& codeId, ITimeType timeType,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllKLines, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveKLinesByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveKLinesByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveKLinesByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveKLinesByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveKLinesByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveKLinesByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveKLinesByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void RemoveOneKLine(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveOneKLine, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveOneKLine, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RemoveOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveOneKLine, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetKLines(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        klines = _makePromiseOutgoing<::IBTrader::IKLines>(true, this, &IQDatabasePrx::_iceI_GetKLines, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKLinesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IKLines>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IKLines, P>(false, this, &IQDatabasePrx::_iceI_GetKLines, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetKLinesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                   ::std::function<void(::IBTrader::IKLines)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IKLines>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetKLines, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneKLine(const ::std::string& codeId, ITimeType timeType, long long int timePos, IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneKLineResult>(true, this, &IQDatabasePrx::_iceI_GetOneKLine, codeId, timeType, timePos, context).get();
        kline = ::std::move(_result.kline);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneKLineResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneKLineResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneKLine, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                     ::std::function<void(bool, ::IBTrader::IKLine)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneKLineResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.kline));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneKLineResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneKLine, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneKLineResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetKLinePairs(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query, IKLinePairs& kLinePairs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        kLinePairs = _makePromiseOutgoing<::IBTrader::IKLinePairs>(true, this, &IQDatabasePrx::_iceI_GetKLinePairs, first, second, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKLinePairsAsync(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IKLinePairs>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IKLinePairs, P>(false, this, &IQDatabasePrx::_iceI_GetKLinePairs, first, second, timeType, query, context);
    }

    ::std::function<void()>
    GetKLinePairsAsync(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query,
                       ::std::function<void(::IBTrader::IKLinePairs)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IKLinePairs>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetKLinePairs, first, second, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKLinePairs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLinePairs>>&, const ::std::string&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    void GetInvalidKLines(const ::std::string& codeId, ITimeType timeType, IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        klines = _makePromiseOutgoing<::IBTrader::IKLines>(true, this, &IQDatabasePrx::_iceI_GetInvalidKLines, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetInvalidKLinesAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IKLines>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IKLines, P>(false, this, &IQDatabasePrx::_iceI_GetInvalidKLines, codeId, timeType, context);
    }

    ::std::function<void()>
    GetInvalidKLinesAsync(const ::std::string& codeId, ITimeType timeType,
                          ::std::function<void(::IBTrader::IKLines)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IKLines>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetInvalidKLines, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_GetInvalidKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountMa(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountMa, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountMaAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountMa, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountMaAsync(const ::std::string& codeId, ITimeType timeType,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountMa, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountMaFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountMaFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountMaFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountMaFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RecountMaFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                              ::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountMaFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountMaFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateMa(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateMa, codeId, timeType, ma, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateMaAsync(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateMa, codeId, timeType, ma, context);
    }

    ::std::function<void()>
    UpdateMaAsync(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateMa, codeId, timeType, ma, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IAvgValue&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllMas(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllMas, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllMasAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllMas, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllMasAsync(const ::std::string& codeId, ITimeType timeType,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllMas, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveMasByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveMasByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveMasByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveMasByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveMasByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveMasByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveMasByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        mas = _makePromiseOutgoing<::IBTrader::IAvgValues>(true, this, &IQDatabasePrx::_iceI_GetMas, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAvgValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAvgValues, P>(false, this, &IQDatabasePrx::_iceI_GetMas, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                ::std::function<void(::IBTrader::IAvgValues)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAvgValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetMas, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneMa(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneMaResult>(true, this, &IQDatabasePrx::_iceI_GetOneMa, codeId, timeType, timePos, context).get();
        ma = ::std::move(_result.ma);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneMaResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneMaResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneMa, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                  ::std::function<void(bool, ::IBTrader::IAvgValue)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneMaResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ma));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneMaResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneMa, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMaResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void RecountVwMa(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountVwMa, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountVwMaAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountVwMa, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountVwMaAsync(const ::std::string& codeId, ITimeType timeType,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountVwMa, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountVwMaFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountVwMaFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountVwMaFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountVwMaFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RecountVwMaFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountVwMaFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountVwMaFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateVwMa(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateVwMa, codeId, timeType, ma, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateVwMaAsync(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateVwMa, codeId, timeType, ma, context);
    }

    ::std::function<void()>
    UpdateVwMaAsync(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateVwMa, codeId, timeType, ma, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IAvgValue&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllVwMas(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllVwMas, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllVwMasAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllVwMas, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllVwMasAsync(const ::std::string& codeId, ITimeType timeType,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllVwMas, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllVwMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveVwMasByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveVwMasByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveVwMasByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveVwMasByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveVwMasByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveVwMasByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveVwMasByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetVwMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        mas = _makePromiseOutgoing<::IBTrader::IAvgValues>(true, this, &IQDatabasePrx::_iceI_GetVwMas, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetVwMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAvgValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAvgValues, P>(false, this, &IQDatabasePrx::_iceI_GetVwMas, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetVwMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                  ::std::function<void(::IBTrader::IAvgValues)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAvgValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetVwMas, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetVwMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneVwMa(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneVwMaResult>(true, this, &IQDatabasePrx::_iceI_GetOneVwMa, codeId, timeType, timePos, context).get();
        ma = ::std::move(_result.ma);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneVwMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneVwMaResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneVwMaResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneVwMa, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneVwMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                    ::std::function<void(bool, ::IBTrader::IAvgValue)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneVwMaResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ma));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneVwMaResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneVwMa, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneVwMaResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void RecountEma(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountEma, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountEmaAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountEma, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountEmaAsync(const ::std::string& codeId, ITimeType timeType,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountEma, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountEmaFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountEmaFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountEmaFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountEmaFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RecountEmaFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountEmaFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountEmaFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateEma(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateEma, codeId, timeType, ema, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateEmaAsync(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateEma, codeId, timeType, ema, context);
    }

    ::std::function<void()>
    UpdateEmaAsync(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ema,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateEma, codeId, timeType, ema, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IAvgValue&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllEmas(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllEmas, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllEmasAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllEmas, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllEmasAsync(const ::std::string& codeId, ITimeType timeType,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllEmas, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllEmas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveEmasByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveEmasByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveEmasByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveEmasByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveEmasByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveEmasByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveEmasByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetEmas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& emas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        emas = _makePromiseOutgoing<::IBTrader::IAvgValues>(true, this, &IQDatabasePrx::_iceI_GetEmas, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetEmasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAvgValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAvgValues, P>(false, this, &IQDatabasePrx::_iceI_GetEmas, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetEmasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                 ::std::function<void(::IBTrader::IAvgValues)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAvgValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetEmas, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetEmas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneEma(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneEmaResult>(true, this, &IQDatabasePrx::_iceI_GetOneEma, codeId, timeType, timePos, context).get();
        ema = ::std::move(_result.ema);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneEmaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneEmaResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneEmaResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneEma, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneEmaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                   ::std::function<void(bool, ::IBTrader::IAvgValue)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneEmaResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ema));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneEmaResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneEma, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneEmaResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void RecountMacd(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountMacd, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountMacdAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountMacd, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountMacdAsync(const ::std::string& codeId, ITimeType timeType,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountMacd, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountMacdFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountMacdFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountMacdFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountMacdFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RecountMacdFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountMacdFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountMacdFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateMacd(const ::std::string& codeId, ITimeType timeType, const IMacdValue& macd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateMacd, codeId, timeType, macd, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateMacdAsync(const ::std::string& codeId, ITimeType timeType, const IMacdValue& macd, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateMacd, codeId, timeType, macd, context);
    }

    ::std::function<void()>
    UpdateMacdAsync(const ::std::string& codeId, ITimeType timeType, const IMacdValue& macd,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateMacd, codeId, timeType, macd, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IMacdValue&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllMacds(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllMacds, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllMacdsAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllMacds, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllMacdsAsync(const ::std::string& codeId, ITimeType timeType,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllMacds, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllMacds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveMacdsByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveMacdsByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveMacdsByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveMacdsByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveMacdsByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveMacdsByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveMacdsByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetMacds(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IMacdValues& macds, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        macds = _makePromiseOutgoing<::IBTrader::IMacdValues>(true, this, &IQDatabasePrx::_iceI_GetMacds, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetMacdsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IMacdValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IMacdValues, P>(false, this, &IQDatabasePrx::_iceI_GetMacds, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetMacdsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                  ::std::function<void(::IBTrader::IMacdValues)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IMacdValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetMacds, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetMacds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IMacdValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneMacd(const ::std::string& codeId, ITimeType timeType, long long int timePos, IMacdValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneMacdResult>(true, this, &IQDatabasePrx::_iceI_GetOneMacd, codeId, timeType, timePos, context).get();
        ma = ::std::move(_result.ma);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneMacdAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneMacdResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneMacdResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneMacd, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneMacdAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                    ::std::function<void(bool, ::IBTrader::IMacdValue)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneMacdResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ma));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneMacdResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneMacd, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMacdResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void RecountDivType(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountDivType, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountDivTypeAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountDivType, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountDivTypeAsync(const ::std::string& codeId, ITimeType timeType,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountDivType, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountDivTypeFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountDivTypeFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountDivTypeFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountDivTypeFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RecountDivTypeFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountDivTypeFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountDivTypeFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateDivType(const ::std::string& codeId, ITimeType timeType, const IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateDivType, codeId, timeType, divtype, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateDivTypeAsync(const ::std::string& codeId, ITimeType timeType, const IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateDivType, codeId, timeType, divtype, context);
    }

    ::std::function<void()>
    UpdateDivTypeAsync(const ::std::string& codeId, ITimeType timeType, const IDivTypeValue& divtype,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateDivType, codeId, timeType, divtype, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IDivTypeValue&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllDivTypes(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllDivTypes, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllDivTypesAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllDivTypes, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllDivTypesAsync(const ::std::string& codeId, ITimeType timeType,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllDivTypes, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllDivTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveDivTypesByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveDivTypesByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveDivTypesByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveDivTypesByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveDivTypesByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveDivTypesByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveDivTypesByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetDivTypes(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IDivTypeValues& divtypes, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        divtypes = _makePromiseOutgoing<::IBTrader::IDivTypeValues>(true, this, &IQDatabasePrx::_iceI_GetDivTypes, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetDivTypesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IDivTypeValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IDivTypeValues, P>(false, this, &IQDatabasePrx::_iceI_GetDivTypes, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetDivTypesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                     ::std::function<void(::IBTrader::IDivTypeValues)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IDivTypeValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetDivTypes, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetDivTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IDivTypeValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneDivType(const ::std::string& codeId, ITimeType timeType, long long int timePos, IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneDivTypeResult>(true, this, &IQDatabasePrx::_iceI_GetOneDivType, codeId, timeType, timePos, context).get();
        divtype = ::std::move(_result.divtype);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneDivTypeAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneDivTypeResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneDivTypeResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneDivType, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneDivTypeAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                       ::std::function<void(bool, ::IBTrader::IDivTypeValue)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneDivTypeResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.divtype));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneDivTypeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneDivType, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneDivTypeResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void RecountAtr(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountAtr, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountAtrAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountAtr, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountAtrAsync(const ::std::string& codeId, ITimeType timeType,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountAtr, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountAtrFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountAtrFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountAtrFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountAtrFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RecountAtrFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountAtrFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountAtrFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateAtr(const ::std::string& codeId, ITimeType timeType, const IAtrValue& artValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateAtr, codeId, timeType, artValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateAtrAsync(const ::std::string& codeId, ITimeType timeType, const IAtrValue& artValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateAtr, codeId, timeType, artValue, context);
    }

    ::std::function<void()>
    UpdateAtrAsync(const ::std::string& codeId, ITimeType timeType, const IAtrValue& artValue,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateAtr, codeId, timeType, artValue, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IAtrValue&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllAtrs(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllAtrs, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllAtrsAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllAtrs, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllAtrsAsync(const ::std::string& codeId, ITimeType timeType,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllAtrs, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllAtrs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveAtrsByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAtrsByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAtrsByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAtrsByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveAtrsByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAtrsByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAtrsByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetAtrs(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAtrValues& avgAtrs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        avgAtrs = _makePromiseOutgoing<::IBTrader::IAtrValues>(true, this, &IQDatabasePrx::_iceI_GetAtrs, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetAtrsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAtrValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAtrValues, P>(false, this, &IQDatabasePrx::_iceI_GetAtrs, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetAtrsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                 ::std::function<void(::IBTrader::IAtrValues)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAtrValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetAtrs, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetAtrs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAtrValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneAtr(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAtrValue& avgAtr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneAtrResult>(true, this, &IQDatabasePrx::_iceI_GetOneAtr, codeId, timeType, timePos, context).get();
        avgAtr = ::std::move(_result.avgAtr);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneAtrAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneAtrResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneAtrResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneAtr, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneAtrAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                   ::std::function<void(bool, ::IBTrader::IAtrValue)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneAtrResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.avgAtr));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneAtrResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneAtr, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneAtrResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IQDatabasePrx() = default;
    friend ::std::shared_ptr<IQDatabasePrx> IceInternal::createProxy<IQDatabasePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond INTERNAL
namespace IBTrader
{

using IQDatabasePtr = ::std::shared_ptr<IQDatabase>;
using IQDatabasePrxPtr = ::std::shared_ptr<IQDatabasePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace IBTrader
{

class IQDatabase;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< IQDatabase>&);
::IceProxy::Ice::Object* upCast(IQDatabase*);
/// \endcond

}

}

namespace IBTrader
{

class IQDatabase;
/// \cond INTERNAL
::Ice::Object* upCast(IQDatabase*);
/// \endcond
typedef ::IceInternal::Handle< IQDatabase> IQDatabasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IBTrader::IQDatabase> IQDatabasePrx;
typedef IQDatabasePrx IQDatabasePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IQDatabasePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace IBTrader
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateTickToDB.
 */
class Callback_IQDatabase_UpdateTickToDB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateTickToDB_Base> Callback_IQDatabase_UpdateTickToDBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetLastUpdateTick.
 */
class Callback_IQDatabase_GetLastUpdateTick_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetLastUpdateTick_Base> Callback_IQDatabase_GetLastUpdateTickPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllTicks.
 */
class Callback_IQDatabase_RemoveAllTicks_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllTicks_Base> Callback_IQDatabase_RemoveAllTicksPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveTicksByRange.
 */
class Callback_IQDatabase_RemoveTicksByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveTicksByRange_Base> Callback_IQDatabase_RemoveTicksByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetTicks.
 */
class Callback_IQDatabase_GetTicks_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetTicks_Base> Callback_IQDatabase_GetTicksPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneTick.
 */
class Callback_IQDatabase_GetOneTick_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneTick_Base> Callback_IQDatabase_GetOneTickPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLine.
 */
class Callback_IQDatabase_UpdateKLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateKLine_Base> Callback_IQDatabase_UpdateKLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllKLines.
 */
class Callback_IQDatabase_RemoveAllKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllKLines_Base> Callback_IQDatabase_RemoveAllKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveKLinesByRange.
 */
class Callback_IQDatabase_RemoveKLinesByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveKLinesByRange_Base> Callback_IQDatabase_RemoveKLinesByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveOneKLine.
 */
class Callback_IQDatabase_RemoveOneKLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveOneKLine_Base> Callback_IQDatabase_RemoveOneKLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLines.
 */
class Callback_IQDatabase_GetKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetKLines_Base> Callback_IQDatabase_GetKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneKLine.
 */
class Callback_IQDatabase_GetOneKLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneKLine_Base> Callback_IQDatabase_GetOneKLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLinePairs.
 */
class Callback_IQDatabase_GetKLinePairs_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetKLinePairs_Base> Callback_IQDatabase_GetKLinePairsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetInvalidKLines.
 */
class Callback_IQDatabase_GetInvalidKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetInvalidKLines_Base> Callback_IQDatabase_GetInvalidKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMa.
 */
class Callback_IQDatabase_RecountMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountMa_Base> Callback_IQDatabase_RecountMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMaFromTimePos.
 */
class Callback_IQDatabase_RecountMaFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountMaFromTimePos_Base> Callback_IQDatabase_RecountMaFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateMa.
 */
class Callback_IQDatabase_UpdateMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateMa_Base> Callback_IQDatabase_UpdateMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllMas.
 */
class Callback_IQDatabase_RemoveAllMas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllMas_Base> Callback_IQDatabase_RemoveAllMasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveMasByRange.
 */
class Callback_IQDatabase_RemoveMasByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveMasByRange_Base> Callback_IQDatabase_RemoveMasByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMas.
 */
class Callback_IQDatabase_GetMas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetMas_Base> Callback_IQDatabase_GetMasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMa.
 */
class Callback_IQDatabase_GetOneMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneMa_Base> Callback_IQDatabase_GetOneMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountVwMa.
 */
class Callback_IQDatabase_RecountVwMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountVwMa_Base> Callback_IQDatabase_RecountVwMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountVwMaFromTimePos.
 */
class Callback_IQDatabase_RecountVwMaFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountVwMaFromTimePos_Base> Callback_IQDatabase_RecountVwMaFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateVwMa.
 */
class Callback_IQDatabase_UpdateVwMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateVwMa_Base> Callback_IQDatabase_UpdateVwMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllVwMas.
 */
class Callback_IQDatabase_RemoveAllVwMas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllVwMas_Base> Callback_IQDatabase_RemoveAllVwMasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveVwMasByRange.
 */
class Callback_IQDatabase_RemoveVwMasByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveVwMasByRange_Base> Callback_IQDatabase_RemoveVwMasByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetVwMas.
 */
class Callback_IQDatabase_GetVwMas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetVwMas_Base> Callback_IQDatabase_GetVwMasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneVwMa.
 */
class Callback_IQDatabase_GetOneVwMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneVwMa_Base> Callback_IQDatabase_GetOneVwMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountEma.
 */
class Callback_IQDatabase_RecountEma_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountEma_Base> Callback_IQDatabase_RecountEmaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountEmaFromTimePos.
 */
class Callback_IQDatabase_RecountEmaFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountEmaFromTimePos_Base> Callback_IQDatabase_RecountEmaFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateEma.
 */
class Callback_IQDatabase_UpdateEma_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateEma_Base> Callback_IQDatabase_UpdateEmaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllEmas.
 */
class Callback_IQDatabase_RemoveAllEmas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllEmas_Base> Callback_IQDatabase_RemoveAllEmasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveEmasByRange.
 */
class Callback_IQDatabase_RemoveEmasByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveEmasByRange_Base> Callback_IQDatabase_RemoveEmasByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetEmas.
 */
class Callback_IQDatabase_GetEmas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetEmas_Base> Callback_IQDatabase_GetEmasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneEma.
 */
class Callback_IQDatabase_GetOneEma_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneEma_Base> Callback_IQDatabase_GetOneEmaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMacd.
 */
class Callback_IQDatabase_RecountMacd_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountMacd_Base> Callback_IQDatabase_RecountMacdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMacdFromTimePos.
 */
class Callback_IQDatabase_RecountMacdFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountMacdFromTimePos_Base> Callback_IQDatabase_RecountMacdFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateMacd.
 */
class Callback_IQDatabase_UpdateMacd_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateMacd_Base> Callback_IQDatabase_UpdateMacdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllMacds.
 */
class Callback_IQDatabase_RemoveAllMacds_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllMacds_Base> Callback_IQDatabase_RemoveAllMacdsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveMacdsByRange.
 */
class Callback_IQDatabase_RemoveMacdsByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveMacdsByRange_Base> Callback_IQDatabase_RemoveMacdsByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMacds.
 */
class Callback_IQDatabase_GetMacds_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetMacds_Base> Callback_IQDatabase_GetMacdsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMacd.
 */
class Callback_IQDatabase_GetOneMacd_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneMacd_Base> Callback_IQDatabase_GetOneMacdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountDivType.
 */
class Callback_IQDatabase_RecountDivType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountDivType_Base> Callback_IQDatabase_RecountDivTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountDivTypeFromTimePos.
 */
class Callback_IQDatabase_RecountDivTypeFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountDivTypeFromTimePos_Base> Callback_IQDatabase_RecountDivTypeFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateDivType.
 */
class Callback_IQDatabase_UpdateDivType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateDivType_Base> Callback_IQDatabase_UpdateDivTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllDivTypes.
 */
class Callback_IQDatabase_RemoveAllDivTypes_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllDivTypes_Base> Callback_IQDatabase_RemoveAllDivTypesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveDivTypesByRange.
 */
class Callback_IQDatabase_RemoveDivTypesByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveDivTypesByRange_Base> Callback_IQDatabase_RemoveDivTypesByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetDivTypes.
 */
class Callback_IQDatabase_GetDivTypes_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetDivTypes_Base> Callback_IQDatabase_GetDivTypesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneDivType.
 */
class Callback_IQDatabase_GetOneDivType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneDivType_Base> Callback_IQDatabase_GetOneDivTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAtr.
 */
class Callback_IQDatabase_RecountAtr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountAtr_Base> Callback_IQDatabase_RecountAtrPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAtrFromTimePos.
 */
class Callback_IQDatabase_RecountAtrFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountAtrFromTimePos_Base> Callback_IQDatabase_RecountAtrFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateAtr.
 */
class Callback_IQDatabase_UpdateAtr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateAtr_Base> Callback_IQDatabase_UpdateAtrPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllAtrs.
 */
class Callback_IQDatabase_RemoveAllAtrs_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllAtrs_Base> Callback_IQDatabase_RemoveAllAtrsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAtrsByRange.
 */
class Callback_IQDatabase_RemoveAtrsByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAtrsByRange_Base> Callback_IQDatabase_RemoveAtrsByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetAtrs.
 */
class Callback_IQDatabase_GetAtrs_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetAtrs_Base> Callback_IQDatabase_GetAtrsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneAtr.
 */
class Callback_IQDatabase_GetOneAtr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneAtr_Base> Callback_IQDatabase_GetOneAtrPtr;

}

namespace IceProxy
{

namespace IBTrader
{

class IQDatabase : public virtual ::Ice::Proxy<IQDatabase, ::IceProxy::Ice::Object>
{
public:

    void UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateTickToDB(_iceI_begin_UpdateTickToDB(tick, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateTickToDB(tick, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::IBTrader::Callback_IQDatabase_UpdateTickToDBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateTickToDBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, context, cb, cookie);
    }

    void end_UpdateTickToDB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateTickToDB(const ::IBTrader::ITick&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::IBTrader::ITick GetLastUpdateTick(::Ice::Int& updateCount, ::Ice::Long& recentUpdateSecnd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetLastUpdateTick(updateCount, recentUpdateSecnd, _iceI_begin_GetLastUpdateTick(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetLastUpdateTick(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::IBTrader::Callback_IQDatabase_GetLastUpdateTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetLastUpdateTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(context, cb, cookie);
    }

    ::IBTrader::ITick end_GetLastUpdateTick(::Ice::Int& updateCount, ::Ice::Long& recentUpdateSecnd, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetLastUpdateTick(::Ice::Int& iceP_updateCount, ::Ice::Long& iceP_recentUpdateSecnd, ::IBTrader::ITick& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetLastUpdateTick(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllTicks(_iceI_begin_RemoveAllTicks(codeId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllTicks(codeId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::IBTrader::Callback_IQDatabase_RemoveAllTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, context, cb, cookie);
    }

    void end_RemoveAllTicks(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllTicks(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveTicksByRange(_iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveTicksByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveTicksByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveTicksByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveTicksByRange(const ::std::string&, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, ::IBTrader::ITicks& ticks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetTicks(ticks, _iceI_begin_GetTicks(codeId, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetTicks(codeId, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, context, cb, cookie);
    }

    void end_GetTicks(::IBTrader::ITicks& ticks, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetTicks(::IBTrader::ITicks& iceP_ticks, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetTicks(const ::std::string&, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, ::IBTrader::ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneTick(tick, _iceI_begin_GetOneTick(codeId, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, context, cb, cookie);
    }

    bool end_GetOneTick(::IBTrader::ITick& tick, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneTick(::IBTrader::ITick& iceP_tick, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneTick(const ::std::string&, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateKLine(_iceI_begin_UpdateKLine(codeId, timeType, kline, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::IBTrader::Callback_IQDatabase_UpdateKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, context, cb, cookie);
    }

    void end_UpdateKLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateKLine(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IKLine&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllKLines(_iceI_begin_RemoveAllKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllKLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllKLines(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveKLinesByRange(_iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveKLinesByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveKLinesByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveKLinesByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveKLinesByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveOneKLine(_iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RemoveOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RemoveOneKLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveOneKLine(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetKLines(klines, _iceI_begin_GetKLines(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetKLines(::IBTrader::IKLines& klines, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKLines(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneKLine(kline, _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneKLine(::IBTrader::IKLine& kline, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneKLine(::IBTrader::IKLine& iceP_kline, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneKLine(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IKLinePairs& kLinePairs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetKLinePairs(kLinePairs, _iceI_begin_GetKLinePairs(first, second, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetKLinePairsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetKLinePairsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, context, cb, cookie);
    }

    void end_GetKLinePairs(::IBTrader::IKLinePairs& kLinePairs, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetKLinePairs(::IBTrader::IKLinePairs& iceP_kLinePairs, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKLinePairs(const ::std::string&, const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::IBTrader::IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetInvalidKLines(klines, _iceI_begin_GetInvalidKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_GetInvalidKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetInvalidKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, context, cb, cookie);
    }

    void end_GetInvalidKLines(::IBTrader::IKLines& klines, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetInvalidKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetInvalidKLines(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountMa(_iceI_begin_RecountMa(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountMa(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMa(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMa(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMa(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMa(codeId, timeType, context, cb, cookie);
    }

    void end_RecountMa(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountMa(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountMaFromTimePos(_iceI_begin_RecountMaFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountMaFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMaFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMaFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RecountMaFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMaFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountMaFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMaFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RecountMaFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountMaFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateMa(_iceI_begin_UpdateMa(codeId, timeType, ma, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateMa(codeId, timeType, ma, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMa(codeId, timeType, ma, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMa(codeId, timeType, ma, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::IBTrader::Callback_IQDatabase_UpdateMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMa(codeId, timeType, ma, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMa(codeId, timeType, ma, context, cb, cookie);
    }

    void end_UpdateMa(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateMa(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IAvgValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllMas(_iceI_begin_RemoveAllMas(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllMas(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMas(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMas(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMas(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMas(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllMas(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllMas(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveMasByRange(_iceI_begin_RemoveMasByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveMasByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMasByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMasByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveMasByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMasByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveMasByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMasByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveMasByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveMasByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetMas(mas, _iceI_begin_GetMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetMas(::IBTrader::IAvgValues& mas, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetMas(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneMa(ma, _iceI_begin_GetOneMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneMa(::IBTrader::IAvgValue& ma, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneMa(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountVwMa(_iceI_begin_RecountVwMa(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountVwMa(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMa(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMa(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMa(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMa(codeId, timeType, context, cb, cookie);
    }

    void end_RecountVwMa(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountVwMa(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountVwMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountVwMaFromTimePos(_iceI_begin_RecountVwMaFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountVwMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountVwMaFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMaFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMaFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RecountVwMaFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMaFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountVwMaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountVwMaFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountVwMaFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RecountVwMaFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountVwMaFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateVwMa(_iceI_begin_UpdateVwMa(codeId, timeType, ma, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateVwMa(codeId, timeType, ma, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateVwMa(codeId, timeType, ma, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateVwMa(codeId, timeType, ma, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::IBTrader::Callback_IQDatabase_UpdateVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateVwMa(codeId, timeType, ma, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ma, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateVwMa(codeId, timeType, ma, context, cb, cookie);
    }

    void end_UpdateVwMa(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateVwMa(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IAvgValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllVwMas(_iceI_begin_RemoveAllVwMas(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllVwMas(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllVwMas(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllVwMas(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllVwMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllVwMas(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllVwMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllVwMas(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllVwMas(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllVwMas(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveVwMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveVwMasByRange(_iceI_begin_RemoveVwMasByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveVwMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveVwMasByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveVwMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveVwMasByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveVwMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveVwMasByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveVwMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveVwMasByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveVwMasByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveVwMasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveVwMasByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveVwMasByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveVwMasByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveVwMasByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetVwMas(mas, _iceI_begin_GetVwMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetVwMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetVwMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetVwMas(::IBTrader::IAvgValues& mas, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetVwMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetVwMas(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneVwMa(ma, _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneVwMa(::IBTrader::IAvgValue& ma, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneVwMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneVwMa(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountEma(_iceI_begin_RecountEma(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountEma(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEma(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEma(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEma(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEma(codeId, timeType, context, cb, cookie);
    }

    void end_RecountEma(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountEma(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountEmaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountEmaFromTimePos(_iceI_begin_RecountEmaFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountEmaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountEmaFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountEmaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEmaFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountEmaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEmaFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountEmaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RecountEmaFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEmaFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountEmaFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountEmaFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountEmaFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RecountEmaFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountEmaFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateEma(_iceI_begin_UpdateEma(codeId, timeType, ema, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateEma(codeId, timeType, ema, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ema, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateEma(codeId, timeType, ema, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ema, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateEma(codeId, timeType, ema, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ema, const ::IBTrader::Callback_IQDatabase_UpdateEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateEma(codeId, timeType, ema, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAvgValue& ema, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateEma(codeId, timeType, ema, context, cb, cookie);
    }

    void end_UpdateEma(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateEma(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IAvgValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllEmas(_iceI_begin_RemoveAllEmas(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllEmas(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllEmas(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllEmas(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllEmasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllEmas(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllEmasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllEmas(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllEmas(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllEmas(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveEmasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveEmasByRange(_iceI_begin_RemoveEmasByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveEmasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveEmasByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveEmasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveEmasByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveEmasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveEmasByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveEmasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveEmasByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveEmasByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveEmasByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveEmasByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveEmasByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveEmasByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveEmasByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAvgValues& emas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetEmas(emas, _iceI_begin_GetEmas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetEmasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetEmasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetEmas(::IBTrader::IAvgValues& emas, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetEmas(::IBTrader::IAvgValues& iceP_emas, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetEmas(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneEma(ema, _iceI_begin_GetOneEma(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneEma(::IBTrader::IAvgValue& ema, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneEma(::IBTrader::IAvgValue& iceP_ema, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneEma(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountMacd(_iceI_begin_RecountMacd(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountMacd(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacd(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacd(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacd(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacd(codeId, timeType, context, cb, cookie);
    }

    void end_RecountMacd(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountMacd(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountMacdFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountMacdFromTimePos(_iceI_begin_RecountMacdFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountMacdFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountMacdFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountMacdFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacdFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMacdFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacdFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMacdFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RecountMacdFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacdFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountMacdFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountMacdFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountMacdFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RecountMacdFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountMacdFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IMacdValue& macd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateMacd(_iceI_begin_UpdateMacd(codeId, timeType, macd, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IMacdValue& macd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateMacd(codeId, timeType, macd, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IMacdValue& macd, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMacd(codeId, timeType, macd, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IMacdValue& macd, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMacd(codeId, timeType, macd, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IMacdValue& macd, const ::IBTrader::Callback_IQDatabase_UpdateMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMacd(codeId, timeType, macd, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IMacdValue& macd, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateMacd(codeId, timeType, macd, context, cb, cookie);
    }

    void end_UpdateMacd(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateMacd(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IMacdValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllMacds(_iceI_begin_RemoveAllMacds(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllMacds(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMacds(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMacds(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllMacdsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMacds(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllMacdsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllMacds(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllMacds(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllMacds(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveMacdsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveMacdsByRange(_iceI_begin_RemoveMacdsByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveMacdsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveMacdsByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveMacdsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMacdsByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveMacdsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMacdsByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveMacdsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveMacdsByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMacdsByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveMacdsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveMacdsByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveMacdsByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveMacdsByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveMacdsByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IMacdValues& macds, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetMacds(macds, _iceI_begin_GetMacds(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetMacdsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetMacdsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetMacds(::IBTrader::IMacdValues& macds, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetMacds(::IBTrader::IMacdValues& iceP_macds, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetMacds(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IMacdValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneMacd(ma, _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneMacd(::IBTrader::IMacdValue& ma, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneMacd(::IBTrader::IMacdValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneMacd(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountDivType(_iceI_begin_RecountDivType(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountDivType(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivType(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivType(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivType(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivType(codeId, timeType, context, cb, cookie);
    }

    void end_RecountDivType(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountDivType(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountDivTypeFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountDivTypeFromTimePos(_iceI_begin_RecountDivTypeFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountDivTypeFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountDivTypeFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountDivTypeFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivTypeFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountDivTypeFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivTypeFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountDivTypeFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RecountDivTypeFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivTypeFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountDivTypeFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountDivTypeFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountDivTypeFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RecountDivTypeFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountDivTypeFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateDivType(_iceI_begin_UpdateDivType(codeId, timeType, divtype, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateDivType(codeId, timeType, divtype, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IDivTypeValue& divtype, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateDivType(codeId, timeType, divtype, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IDivTypeValue& divtype, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateDivType(codeId, timeType, divtype, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IDivTypeValue& divtype, const ::IBTrader::Callback_IQDatabase_UpdateDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateDivType(codeId, timeType, divtype, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IDivTypeValue& divtype, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateDivType(codeId, timeType, divtype, context, cb, cookie);
    }

    void end_UpdateDivType(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateDivType(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IDivTypeValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllDivTypes(_iceI_begin_RemoveAllDivTypes(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllDivTypes(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllDivTypes(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllDivTypes(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllDivTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllDivTypes(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllDivTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllDivTypes(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllDivTypes(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllDivTypes(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveDivTypesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveDivTypesByRange(_iceI_begin_RemoveDivTypesByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveDivTypesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveDivTypesByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveDivTypesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveDivTypesByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveDivTypesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveDivTypesByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveDivTypesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveDivTypesByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveDivTypesByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveDivTypesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveDivTypesByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveDivTypesByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveDivTypesByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveDivTypesByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IDivTypeValues& divtypes, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetDivTypes(divtypes, _iceI_begin_GetDivTypes(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetDivTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetDivTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetDivTypes(::IBTrader::IDivTypeValues& divtypes, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetDivTypes(::IBTrader::IDivTypeValues& iceP_divtypes, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetDivTypes(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneDivType(divtype, _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneDivType(::IBTrader::IDivTypeValue& divtype, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneDivType(::IBTrader::IDivTypeValue& iceP_divtype, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneDivType(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountAtr(_iceI_begin_RecountAtr(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountAtr(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtr(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtr(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtr(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtr(codeId, timeType, context, cb, cookie);
    }

    void end_RecountAtr(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountAtr(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountAtrFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountAtrFromTimePos(_iceI_begin_RecountAtrFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountAtrFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountAtrFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountAtrFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtrFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAtrFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtrFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAtrFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RecountAtrFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtrFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAtrFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountAtrFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAtrFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RecountAtrFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountAtrFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAtrValue& artValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateAtr(_iceI_begin_UpdateAtr(codeId, timeType, artValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAtrValue& artValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateAtr(codeId, timeType, artValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAtrValue& artValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAtr(codeId, timeType, artValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAtrValue& artValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAtr(codeId, timeType, artValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAtrValue& artValue, const ::IBTrader::Callback_IQDatabase_UpdateAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAtr(codeId, timeType, artValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IAtrValue& artValue, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAtr(codeId, timeType, artValue, context, cb, cookie);
    }

    void end_UpdateAtr(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateAtr(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IAtrValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllAtrs(_iceI_begin_RemoveAllAtrs(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllAtrs(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllAtrs(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllAtrs(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllAtrsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllAtrs(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllAtrsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllAtrs(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllAtrs(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllAtrs(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAtrsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAtrsByRange(_iceI_begin_RemoveAtrsByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAtrsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAtrsByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAtrsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAtrsByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAtrsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAtrsByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAtrsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveAtrsByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAtrsByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAtrsByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAtrsByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAtrsByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveAtrsByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAtrsByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAtrValues& avgAtrs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetAtrs(avgAtrs, _iceI_begin_GetAtrs(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetAtrsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetAtrsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetAtrs(::IBTrader::IAtrValues& avgAtrs, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetAtrs(::IBTrader::IAtrValues& iceP_avgAtrs, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetAtrs(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAtrValue& avgAtr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneAtr(avgAtr, _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneAtr(::IBTrader::IAtrValue& avgAtr, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneAtr(::IBTrader::IAtrValue& iceP_avgAtr, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneAtr(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace IBTrader
{

class IQDatabase : public virtual ::Ice::Object
{
public:

    typedef IQDatabasePrx ProxyType;
    typedef IQDatabasePtr PointerType;

    virtual ~IQDatabase();

#ifdef ICE_CPP11_COMPILER
    IQDatabase() = default;
    IQDatabase(const IQDatabase&) = default;
    IQDatabase& operator=(const IQDatabase&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void UpdateTickToDB(const ITick& tick, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTickToDB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ITick GetLastUpdateTick(::Ice::Int& updateCount, ::Ice::Long& recentUpdateSecnd, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLastUpdateTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllTicks(const ::std::string& codeId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveTicksByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetTicks(const ::std::string& codeId, const IQuery& query, ITicks& ticks, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, ITick& tick, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateKLine(const ::std::string& codeId, ITimeType timeType, const IKLine& kline, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllKLines(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveKLinesByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveKLinesByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveOneKLine(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLines(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IKLines& klines, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneKLine(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IKLine& kline, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLinePairs(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query, IKLinePairs& kLinePairs, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLinePairs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetInvalidKLines(const ::std::string& codeId, ITimeType timeType, IKLines& klines, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetInvalidKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMa(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMaFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMaFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateMa(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllMas(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveMasByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveMasByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneMa(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAvgValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountVwMa(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountVwMaFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountVwMaFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateVwMa(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllVwMas(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllVwMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveVwMasByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveVwMasByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetVwMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVwMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneVwMa(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAvgValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountEma(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountEmaFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountEmaFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateEma(const ::std::string& codeId, ITimeType timeType, const IAvgValue& ema, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllEmas(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllEmas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveEmasByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveEmasByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetEmas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& emas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetEmas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneEma(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAvgValue& ema, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMacd(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountMacdFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountMacdFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateMacd(const ::std::string& codeId, ITimeType timeType, const IMacdValue& macd, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllMacds(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllMacds(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveMacdsByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveMacdsByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMacds(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IMacdValues& macds, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMacds(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneMacd(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IMacdValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountDivType(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountDivTypeFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountDivTypeFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateDivType(const ::std::string& codeId, ITimeType timeType, const IDivTypeValue& divtype, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllDivTypes(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllDivTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveDivTypesByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveDivTypesByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetDivTypes(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IDivTypeValues& divtypes, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetDivTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneDivType(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IDivTypeValue& divtype, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountAtr(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountAtrFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountAtrFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateAtr(const ::std::string& codeId, ITimeType timeType, const IAtrValue& artValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllAtrs(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllAtrs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAtrsByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAtrsByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetAtrs(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAtrValues& avgAtrs, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAtrs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneAtr(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAtrValue& avgAtr, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const IQDatabase& lhs, const IQDatabase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IQDatabase& lhs, const IQDatabase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

namespace IBTrader
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateTickToDB.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateTickToDB : public Callback_IQDatabase_UpdateTickToDB_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateTickToDB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateTickToDB.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateTickToDB : public Callback_IQDatabase_UpdateTickToDB_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateTickToDB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetLastUpdateTick.
 */
template<class T>
class CallbackNC_IQDatabase_GetLastUpdateTick : public Callback_IQDatabase_GetLastUpdateTick_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ITick&, ::Ice::Int, ::Ice::Long);

    CallbackNC_IQDatabase_GetLastUpdateTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_updateCount;
        ::Ice::Long iceP_recentUpdateSecnd;
        ITick ret;
        try
        {
            ret = proxy->end_GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_updateCount, iceP_recentUpdateSecnd);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetLastUpdateTick<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(T* instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetLastUpdateTick<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetLastUpdateTick.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetLastUpdateTick : public Callback_IQDatabase_GetLastUpdateTick_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ITick&, ::Ice::Int, ::Ice::Long, const CT&);

    Callback_IQDatabase_GetLastUpdateTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_updateCount;
        ::Ice::Long iceP_recentUpdateSecnd;
        ITick ret;
        try
        {
            ret = proxy->end_GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_updateCount, iceP_recentUpdateSecnd, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetLastUpdateTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(T* instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetLastUpdateTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllTicks.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllTicks : public Callback_IQDatabase_RemoveAllTicks_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllTicks.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllTicks : public Callback_IQDatabase_RemoveAllTicks_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveTicksByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveTicksByRange : public Callback_IQDatabase_RemoveTicksByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveTicksByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveTicksByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveTicksByRange : public Callback_IQDatabase_RemoveTicksByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveTicksByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetTicks.
 */
template<class T>
class CallbackNC_IQDatabase_GetTicks : public Callback_IQDatabase_GetTicks_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ITicks&);

    CallbackNC_IQDatabase_GetTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITicks iceP_ticks;
        try
        {
            proxy->end_GetTicks(iceP_ticks, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_ticks);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITicks&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(T* instance, void (T::*cb)(const ITicks&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetTicks.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetTicks : public Callback_IQDatabase_GetTicks_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ITicks&, const CT&);

    Callback_IQDatabase_GetTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITicks iceP_ticks;
        try
        {
            proxy->end_GetTicks(iceP_ticks, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_ticks, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T, typename CT> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITicks&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T, typename CT> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(T* instance, void (T::*cb)(const ITicks&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneTick.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneTick : public Callback_IQDatabase_GetOneTick_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ITick&);

    CallbackNC_IQDatabase_GetOneTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITick iceP_tick;
        bool ret;
        try
        {
            ret = proxy->end_GetOneTick(iceP_tick, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_tick);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ITick&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneTick<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(T* instance, void (T::*cb)(bool, const ITick&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneTick<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneTick.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneTick : public Callback_IQDatabase_GetOneTick_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ITick&, const CT&);

    Callback_IQDatabase_GetOneTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITick iceP_tick;
        bool ret;
        try
        {
            ret = proxy->end_GetOneTick(iceP_tick, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_tick, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ITick&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(T* instance, void (T::*cb)(bool, const ITick&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLine.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateKLine : public Callback_IQDatabase_UpdateKLine_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLine.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateKLine : public Callback_IQDatabase_UpdateKLine_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllKLines.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllKLines : public Callback_IQDatabase_RemoveAllKLines_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllKLines : public Callback_IQDatabase_RemoveAllKLines_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveKLinesByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveKLinesByRange : public Callback_IQDatabase_RemoveKLinesByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveKLinesByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveKLinesByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveKLinesByRange : public Callback_IQDatabase_RemoveKLinesByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveKLinesByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveOneKLine.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveOneKLine : public Callback_IQDatabase_RemoveOneKLine_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveOneKLine.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveOneKLine : public Callback_IQDatabase_RemoveOneKLine_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLines.
 */
template<class T>
class CallbackNC_IQDatabase_GetKLines : public Callback_IQDatabase_GetKLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IKLines&);

    CallbackNC_IQDatabase_GetKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_klines);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(T* instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetKLines : public Callback_IQDatabase_GetKLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IKLines&, const CT&);

    Callback_IQDatabase_GetKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_klines, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(T* instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneKLine.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneKLine : public Callback_IQDatabase_GetOneKLine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IKLine&);

    CallbackNC_IQDatabase_GetOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLine iceP_kline;
        bool ret;
        try
        {
            ret = proxy->end_GetOneKLine(iceP_kline, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_kline);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IKLine&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(T* instance, void (T::*cb)(bool, const IKLine&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneKLine.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneKLine : public Callback_IQDatabase_GetOneKLine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IKLine&, const CT&);

    Callback_IQDatabase_GetOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLine iceP_kline;
        bool ret;
        try
        {
            ret = proxy->end_GetOneKLine(iceP_kline, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_kline, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IKLine&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(T* instance, void (T::*cb)(bool, const IKLine&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLinePairs.
 */
template<class T>
class CallbackNC_IQDatabase_GetKLinePairs : public Callback_IQDatabase_GetKLinePairs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IKLinePairs&);

    CallbackNC_IQDatabase_GetKLinePairs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLinePairs iceP_kLinePairs;
        try
        {
            proxy->end_GetKLinePairs(iceP_kLinePairs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_kLinePairs);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLinePairs&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLinePairs<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(T* instance, void (T::*cb)(const IKLinePairs&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLinePairs<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLinePairs.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetKLinePairs : public Callback_IQDatabase_GetKLinePairs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IKLinePairs&, const CT&);

    Callback_IQDatabase_GetKLinePairs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLinePairs iceP_kLinePairs;
        try
        {
            proxy->end_GetKLinePairs(iceP_kLinePairs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_kLinePairs, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLinePairs&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLinePairs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(T* instance, void (T::*cb)(const IKLinePairs&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLinePairs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetInvalidKLines.
 */
template<class T>
class CallbackNC_IQDatabase_GetInvalidKLines : public Callback_IQDatabase_GetInvalidKLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IKLines&);

    CallbackNC_IQDatabase_GetInvalidKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetInvalidKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_klines);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetInvalidKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(T* instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetInvalidKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetInvalidKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetInvalidKLines : public Callback_IQDatabase_GetInvalidKLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IKLines&, const CT&);

    Callback_IQDatabase_GetInvalidKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetInvalidKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_klines, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetInvalidKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(T* instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetInvalidKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMa.
 */
template<class T>
class CallbackNC_IQDatabase_RecountMa : public Callback_IQDatabase_RecountMa_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMa<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMa<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountMa : public Callback_IQDatabase_RecountMa_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaPtr
newCallback_IQDatabase_RecountMa(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMaFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_RecountMaFromTimePos : public Callback_IQDatabase_RecountMaFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountMaFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMaFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMaFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMaFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMaFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMaFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountMaFromTimePos : public Callback_IQDatabase_RecountMaFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountMaFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMaFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMaFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMaFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMaFromTimePosPtr
newCallback_IQDatabase_RecountMaFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMaFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateMa.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateMa : public Callback_IQDatabase_UpdateMa_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMa<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMa<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateMa : public Callback_IQDatabase_UpdateMa_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMaPtr
newCallback_IQDatabase_UpdateMa(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllMas.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllMas : public Callback_IQDatabase_RemoveAllMas_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMas<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMas<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllMas.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllMas : public Callback_IQDatabase_RemoveAllMas_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMasPtr
newCallback_IQDatabase_RemoveAllMas(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveMasByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveMasByRange : public Callback_IQDatabase_RemoveMasByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveMasByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMasByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMasByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMasByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMasByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveMasByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveMasByRange : public Callback_IQDatabase_RemoveMasByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveMasByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMasByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMasByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMasByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMasByRangePtr
newCallback_IQDatabase_RemoveMasByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMasByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMas.
 */
template<class T>
class CallbackNC_IQDatabase_GetMas : public Callback_IQDatabase_GetMas_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAvgValues&);

    CallbackNC_IQDatabase_GetMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_mas);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(T* instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMas<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMas.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetMas : public Callback_IQDatabase_GetMas_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAvgValues&, const CT&);

    Callback_IQDatabase_GetMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_mas, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(T* instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMa.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneMa : public Callback_IQDatabase_GetOneMa_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAvgValue&);

    CallbackNC_IQDatabase_GetOneMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ma);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(T* instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMa<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneMa : public Callback_IQDatabase_GetOneMa_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAvgValue&, const CT&);

    Callback_IQDatabase_GetOneMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ma, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(T* instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountVwMa.
 */
template<class T>
class CallbackNC_IQDatabase_RecountVwMa : public Callback_IQDatabase_RecountVwMa_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMa<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMa<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountVwMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountVwMa : public Callback_IQDatabase_RecountVwMa_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaPtr
newCallback_IQDatabase_RecountVwMa(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountVwMaFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_RecountVwMaFromTimePos : public Callback_IQDatabase_RecountVwMaFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountVwMaFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMaFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMaFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMaFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountVwMaFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountVwMaFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountVwMaFromTimePos : public Callback_IQDatabase_RecountVwMaFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountVwMaFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMaFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMaFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMaFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountVwMaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountVwMaFromTimePosPtr
newCallback_IQDatabase_RecountVwMaFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountVwMaFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateVwMa.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateVwMa : public Callback_IQDatabase_UpdateVwMa_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateVwMa<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateVwMa<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateVwMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateVwMa : public Callback_IQDatabase_UpdateVwMa_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateVwMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateVwMaPtr
newCallback_IQDatabase_UpdateVwMa(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateVwMa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllVwMas.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllVwMas : public Callback_IQDatabase_RemoveAllVwMas_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllVwMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllVwMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllVwMas<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllVwMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllVwMas<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllVwMas.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllVwMas : public Callback_IQDatabase_RemoveAllVwMas_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllVwMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllVwMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllVwMas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllVwMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllVwMasPtr
newCallback_IQDatabase_RemoveAllVwMas(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllVwMas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveVwMasByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveVwMasByRange : public Callback_IQDatabase_RemoveVwMasByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveVwMasByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveVwMasByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveVwMasByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveVwMasByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveVwMasByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveVwMasByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveVwMasByRange : public Callback_IQDatabase_RemoveVwMasByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveVwMasByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveVwMasByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveVwMasByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveVwMasByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveVwMasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveVwMasByRangePtr
newCallback_IQDatabase_RemoveVwMasByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveVwMasByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetVwMas.
 */
template<class T>
class CallbackNC_IQDatabase_GetVwMas : public Callback_IQDatabase_GetVwMas_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAvgValues&);

    CallbackNC_IQDatabase_GetVwMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetVwMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_mas);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetVwMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(T* instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetVwMas<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetVwMas.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetVwMas : public Callback_IQDatabase_GetVwMas_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAvgValues&, const CT&);

    Callback_IQDatabase_GetVwMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetVwMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_mas, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetVwMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(T* instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetVwMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneVwMa.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneVwMa : public Callback_IQDatabase_GetOneVwMa_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAvgValue&);

    CallbackNC_IQDatabase_GetOneVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneVwMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ma);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(T* instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneVwMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneVwMa : public Callback_IQDatabase_GetOneVwMa_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAvgValue&, const CT&);

    Callback_IQDatabase_GetOneVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneVwMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ma, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(T* instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountEma.
 */
template<class T>
class CallbackNC_IQDatabase_RecountEma : public Callback_IQDatabase_RecountEma_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEma<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEma<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEma<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEma<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountEma.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountEma : public Callback_IQDatabase_RecountEma_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEma<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEma.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaPtr
newCallback_IQDatabase_RecountEma(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEma<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountEmaFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_RecountEmaFromTimePos : public Callback_IQDatabase_RecountEmaFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountEmaFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEmaFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEmaFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEmaFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountEmaFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountEmaFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountEmaFromTimePos : public Callback_IQDatabase_RecountEmaFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountEmaFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEmaFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEmaFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEmaFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountEmaFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountEmaFromTimePosPtr
newCallback_IQDatabase_RecountEmaFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountEmaFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateEma.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateEma : public Callback_IQDatabase_UpdateEma_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateEma<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateEma<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateEma<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateEma<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateEma.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateEma : public Callback_IQDatabase_UpdateEma_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateEma<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateEma.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateEmaPtr
newCallback_IQDatabase_UpdateEma(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateEma<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllEmas.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllEmas : public Callback_IQDatabase_RemoveAllEmas_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllEmas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllEmas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllEmas<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllEmas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllEmas<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllEmas.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllEmas : public Callback_IQDatabase_RemoveAllEmas_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllEmas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllEmas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllEmas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllEmas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllEmas.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllEmasPtr
newCallback_IQDatabase_RemoveAllEmas(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllEmas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveEmasByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveEmasByRange : public Callback_IQDatabase_RemoveEmasByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveEmasByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveEmasByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveEmasByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveEmasByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveEmasByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveEmasByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveEmasByRange : public Callback_IQDatabase_RemoveEmasByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveEmasByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveEmasByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveEmasByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveEmasByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveEmasByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveEmasByRangePtr
newCallback_IQDatabase_RemoveEmasByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveEmasByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetEmas.
 */
template<class T>
class CallbackNC_IQDatabase_GetEmas : public Callback_IQDatabase_GetEmas_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAvgValues&);

    CallbackNC_IQDatabase_GetEmas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_emas;
        try
        {
            proxy->end_GetEmas(iceP_emas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_emas);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetEmas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(T* instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetEmas<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetEmas.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetEmas : public Callback_IQDatabase_GetEmas_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAvgValues&, const CT&);

    Callback_IQDatabase_GetEmas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_emas;
        try
        {
            proxy->end_GetEmas(iceP_emas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_emas, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T, typename CT> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetEmas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T, typename CT> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(T* instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetEmas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneEma.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneEma : public Callback_IQDatabase_GetOneEma_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAvgValue&);

    CallbackNC_IQDatabase_GetOneEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ema;
        bool ret;
        try
        {
            ret = proxy->end_GetOneEma(iceP_ema, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ema);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneEma<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(T* instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneEma<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneEma.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneEma : public Callback_IQDatabase_GetOneEma_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAvgValue&, const CT&);

    Callback_IQDatabase_GetOneEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ema;
        bool ret;
        try
        {
            ret = proxy->end_GetOneEma(iceP_ema, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ema, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(T* instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMacd.
 */
template<class T>
class CallbackNC_IQDatabase_RecountMacd : public Callback_IQDatabase_RecountMacd_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacd<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacd<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMacd.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountMacd : public Callback_IQDatabase_RecountMacd_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacd<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacd.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdPtr
newCallback_IQDatabase_RecountMacd(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacd<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMacdFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_RecountMacdFromTimePos : public Callback_IQDatabase_RecountMacdFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountMacdFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacdFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacdFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacdFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountMacdFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountMacdFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountMacdFromTimePos : public Callback_IQDatabase_RecountMacdFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountMacdFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacdFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacdFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacdFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountMacdFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountMacdFromTimePosPtr
newCallback_IQDatabase_RecountMacdFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountMacdFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateMacd.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateMacd : public Callback_IQDatabase_UpdateMacd_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMacd<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateMacd<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateMacd.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateMacd : public Callback_IQDatabase_UpdateMacd_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMacd<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateMacd.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateMacdPtr
newCallback_IQDatabase_UpdateMacd(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateMacd<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllMacds.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllMacds : public Callback_IQDatabase_RemoveAllMacds_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllMacds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMacds<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMacds<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMacds<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllMacds<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllMacds.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllMacds : public Callback_IQDatabase_RemoveAllMacds_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllMacds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMacds<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMacds<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMacds<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllMacds.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllMacdsPtr
newCallback_IQDatabase_RemoveAllMacds(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllMacds<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveMacdsByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveMacdsByRange : public Callback_IQDatabase_RemoveMacdsByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveMacdsByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMacdsByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMacdsByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMacdsByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveMacdsByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveMacdsByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveMacdsByRange : public Callback_IQDatabase_RemoveMacdsByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveMacdsByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMacdsByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMacdsByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMacdsByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveMacdsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveMacdsByRangePtr
newCallback_IQDatabase_RemoveMacdsByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveMacdsByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMacds.
 */
template<class T>
class CallbackNC_IQDatabase_GetMacds : public Callback_IQDatabase_GetMacds_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IMacdValues&);

    CallbackNC_IQDatabase_GetMacds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValues iceP_macds;
        try
        {
            proxy->end_GetMacds(iceP_macds, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_macds);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(const IceUtil::Handle<T>& instance, void (T::*cb)(const IMacdValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMacds<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(T* instance, void (T::*cb)(const IMacdValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMacds<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMacds.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetMacds : public Callback_IQDatabase_GetMacds_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IMacdValues&, const CT&);

    Callback_IQDatabase_GetMacds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValues iceP_macds;
        try
        {
            proxy->end_GetMacds(iceP_macds, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_macds, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T, typename CT> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(const IceUtil::Handle<T>& instance, void (T::*cb)(const IMacdValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMacds<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T, typename CT> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(T* instance, void (T::*cb)(const IMacdValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMacds<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMacd.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneMacd : public Callback_IQDatabase_GetOneMacd_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IMacdValue&);

    CallbackNC_IQDatabase_GetOneMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMacd(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ma);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IMacdValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(T* instance, void (T::*cb)(bool, const IMacdValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMacd.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneMacd : public Callback_IQDatabase_GetOneMacd_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IMacdValue&, const CT&);

    Callback_IQDatabase_GetOneMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMacd(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ma, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IMacdValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(T* instance, void (T::*cb)(bool, const IMacdValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountDivType.
 */
template<class T>
class CallbackNC_IQDatabase_RecountDivType : public Callback_IQDatabase_RecountDivType_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivType<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivType<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountDivType.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountDivType : public Callback_IQDatabase_RecountDivType_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivType<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivType.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypePtr
newCallback_IQDatabase_RecountDivType(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivType<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountDivTypeFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_RecountDivTypeFromTimePos : public Callback_IQDatabase_RecountDivTypeFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountDivTypeFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivTypeFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivTypeFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivTypeFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountDivTypeFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountDivTypeFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountDivTypeFromTimePos : public Callback_IQDatabase_RecountDivTypeFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountDivTypeFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivTypeFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivTypeFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivTypeFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountDivTypeFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountDivTypeFromTimePosPtr
newCallback_IQDatabase_RecountDivTypeFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountDivTypeFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateDivType.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateDivType : public Callback_IQDatabase_UpdateDivType_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateDivType<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateDivType<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateDivType.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateDivType : public Callback_IQDatabase_UpdateDivType_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateDivType<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateDivType.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateDivTypePtr
newCallback_IQDatabase_UpdateDivType(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateDivType<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllDivTypes.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllDivTypes : public Callback_IQDatabase_RemoveAllDivTypes_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllDivTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllDivTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllDivTypes<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllDivTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllDivTypes<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllDivTypes.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllDivTypes : public Callback_IQDatabase_RemoveAllDivTypes_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllDivTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllDivTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllDivTypes<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllDivTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllDivTypesPtr
newCallback_IQDatabase_RemoveAllDivTypes(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllDivTypes<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveDivTypesByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveDivTypesByRange : public Callback_IQDatabase_RemoveDivTypesByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveDivTypesByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveDivTypesByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveDivTypesByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveDivTypesByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveDivTypesByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveDivTypesByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveDivTypesByRange : public Callback_IQDatabase_RemoveDivTypesByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveDivTypesByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveDivTypesByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveDivTypesByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveDivTypesByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveDivTypesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveDivTypesByRangePtr
newCallback_IQDatabase_RemoveDivTypesByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveDivTypesByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetDivTypes.
 */
template<class T>
class CallbackNC_IQDatabase_GetDivTypes : public Callback_IQDatabase_GetDivTypes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IDivTypeValues&);

    CallbackNC_IQDatabase_GetDivTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValues iceP_divtypes;
        try
        {
            proxy->end_GetDivTypes(iceP_divtypes, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_divtypes);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const IDivTypeValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetDivTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(T* instance, void (T::*cb)(const IDivTypeValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetDivTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetDivTypes.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetDivTypes : public Callback_IQDatabase_GetDivTypes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IDivTypeValues&, const CT&);

    Callback_IQDatabase_GetDivTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValues iceP_divtypes;
        try
        {
            proxy->end_GetDivTypes(iceP_divtypes, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_divtypes, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const IDivTypeValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetDivTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(T* instance, void (T::*cb)(const IDivTypeValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetDivTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneDivType.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneDivType : public Callback_IQDatabase_GetOneDivType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IDivTypeValue&);

    CallbackNC_IQDatabase_GetOneDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValue iceP_divtype;
        bool ret;
        try
        {
            ret = proxy->end_GetOneDivType(iceP_divtype, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_divtype);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IDivTypeValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(T* instance, void (T::*cb)(bool, const IDivTypeValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneDivType.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneDivType : public Callback_IQDatabase_GetOneDivType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IDivTypeValue&, const CT&);

    Callback_IQDatabase_GetOneDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValue iceP_divtype;
        bool ret;
        try
        {
            ret = proxy->end_GetOneDivType(iceP_divtype, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_divtype, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IDivTypeValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(T* instance, void (T::*cb)(bool, const IDivTypeValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAtr.
 */
template<class T>
class CallbackNC_IQDatabase_RecountAtr : public Callback_IQDatabase_RecountAtr_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtr<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtr<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAtr.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountAtr : public Callback_IQDatabase_RecountAtr_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtr.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrPtr
newCallback_IQDatabase_RecountAtr(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAtrFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_RecountAtrFromTimePos : public Callback_IQDatabase_RecountAtrFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountAtrFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtrFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtrFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtrFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAtrFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAtrFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountAtrFromTimePos : public Callback_IQDatabase_RecountAtrFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountAtrFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtrFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtrFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtrFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAtrFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAtrFromTimePosPtr
newCallback_IQDatabase_RecountAtrFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAtrFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateAtr.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateAtr : public Callback_IQDatabase_UpdateAtr_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAtr<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAtr<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateAtr.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateAtr : public Callback_IQDatabase_UpdateAtr_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAtr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAtr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAtr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAtr.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAtrPtr
newCallback_IQDatabase_UpdateAtr(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAtr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllAtrs.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllAtrs : public Callback_IQDatabase_RemoveAllAtrs_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllAtrs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllAtrs<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllAtrs<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllAtrs<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllAtrs<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllAtrs.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllAtrs : public Callback_IQDatabase_RemoveAllAtrs_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllAtrs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllAtrs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllAtrs<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllAtrs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllAtrsPtr
newCallback_IQDatabase_RemoveAllAtrs(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllAtrs<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAtrsByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAtrsByRange : public Callback_IQDatabase_RemoveAtrsByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAtrsByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAtrsByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAtrsByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAtrsByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAtrsByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAtrsByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAtrsByRange : public Callback_IQDatabase_RemoveAtrsByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAtrsByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAtrsByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAtrsByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAtrsByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAtrsByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAtrsByRangePtr
newCallback_IQDatabase_RemoveAtrsByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAtrsByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetAtrs.
 */
template<class T>
class CallbackNC_IQDatabase_GetAtrs : public Callback_IQDatabase_GetAtrs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAtrValues&);

    CallbackNC_IQDatabase_GetAtrs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValues iceP_avgAtrs;
        try
        {
            proxy->end_GetAtrs(iceP_avgAtrs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_avgAtrs);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAtrValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetAtrs<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(T* instance, void (T::*cb)(const IAtrValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetAtrs<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetAtrs.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetAtrs : public Callback_IQDatabase_GetAtrs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAtrValues&, const CT&);

    Callback_IQDatabase_GetAtrs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValues iceP_avgAtrs;
        try
        {
            proxy->end_GetAtrs(iceP_avgAtrs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_avgAtrs, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAtrValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetAtrs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(T* instance, void (T::*cb)(const IAtrValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetAtrs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneAtr.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneAtr : public Callback_IQDatabase_GetOneAtr_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAtrValue&);

    CallbackNC_IQDatabase_GetOneAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValue iceP_avgAtr;
        bool ret;
        try
        {
            ret = proxy->end_GetOneAtr(iceP_avgAtr, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_avgAtr);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAtrValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(T* instance, void (T::*cb)(bool, const IAtrValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneAtr.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneAtr : public Callback_IQDatabase_GetOneAtr_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAtrValue&, const CT&);

    Callback_IQDatabase_GetOneAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValue iceP_avgAtr;
        bool ret;
        try
        {
            ret = proxy->end_GetOneAtr(iceP_avgAtr, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_avgAtr, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAtrValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneAtr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(T* instance, void (T::*cb)(bool, const IAtrValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneAtr<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
