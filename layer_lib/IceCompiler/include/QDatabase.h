//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `QDatabase.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __QDatabase_h__
#define __QDatabase_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <QStruc.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace IBTrader
{

class IQDatabase;
class IQDatabasePrx;

}

namespace IBTrader
{

class IQDatabase : public virtual ::Ice::Object
{
public:

    using ProxyType = IQDatabasePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int IdlCount(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_IdlCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool IsAllIdle(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_IsAllIdle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int TaskCount(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_TaskCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateTickToDB(ITick tick, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTickToDB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetLastUpdateTick.
     */
    struct GetLastUpdateTickResult
    {
        ITick returnValue;
        int updateCount;
        long long int recentUpdateSecnd;
    };

    virtual ITick GetLastUpdateTick(int& updateCount, long long int& recentUpdateSecnd, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLastUpdateTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DelCodeId(::std::string codeId, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_DelCodeId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllTicks(::std::string codeId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveTicksByRange(::std::string codeId, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveTicksByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetTicks(::std::string codeId, IQuery query, ITicks& ticks, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneTick.
     */
    struct GetOneTickResult
    {
        bool returnValue;
        ITick tick;
    };

    virtual bool GetOneTick(::std::string codeId, long long int timePos, ITick& tick, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateKLine(::std::string codeId, ITimeType timeType, IKLine kline, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateKLines(::std::string codeId, ITimeType timeType, IKLines klines, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllKLines(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveKLinesByRange(::std::string codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveKLinesByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveOneKLine(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLines(::std::string codeId, ITimeType timeType, IQuery query, IKLines& klines, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneKLine.
     */
    struct GetOneKLineResult
    {
        bool returnValue;
        IKLine kline;
    };

    virtual bool GetOneKLine(::std::string codeId, ITimeType timeType, long long int timePos, IKLine& kline, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLinePairs(::std::string first, ::std::string second, ITimeType timeType, IQuery query, IKLinePairs& kLinePairs, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLinePairs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetInvalidKLines(::std::string codeId, ITimeType timeType, IKLines& klines, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetInvalidKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountAllIndex(::std::string codeId, ITimeType timeType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountAllIndex(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateAllIndexFromTimePos(::std::string codeId, ITimeType timeType, long long int timePos, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateAllIndexFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMas(::std::string codeId, ITimeType timeType, IQuery query, IAvgValues& mas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneMa.
     */
    struct GetOneMaResult
    {
        bool returnValue;
        IAvgValue ma;
    };

    virtual bool GetOneMa(::std::string codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetVwMas(::std::string codeId, ITimeType timeType, IQuery query, IAvgValues& mas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVwMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneVwMa.
     */
    struct GetOneVwMaResult
    {
        bool returnValue;
        IAvgValue ma;
    };

    virtual bool GetOneVwMa(::std::string codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetEmas(::std::string codeId, ITimeType timeType, IQuery query, IAvgValues& emas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetEmas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneEma.
     */
    struct GetOneEmaResult
    {
        bool returnValue;
        IAvgValue ema;
    };

    virtual bool GetOneEma(::std::string codeId, ITimeType timeType, long long int timePos, IAvgValue& ema, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMacds(::std::string codeId, ITimeType timeType, IQuery query, IMacdValues& macds, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMacds(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneMacd.
     */
    struct GetOneMacdResult
    {
        bool returnValue;
        IMacdValue ma;
    };

    virtual bool GetOneMacd(::std::string codeId, ITimeType timeType, long long int timePos, IMacdValue& ma, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetDivTypes(::std::string codeId, ITimeType timeType, IQuery query, IDivTypeValues& divtypes, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetDivTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneDivType.
     */
    struct GetOneDivTypeResult
    {
        bool returnValue;
        IDivTypeValue divtype;
    };

    virtual bool GetOneDivType(::std::string codeId, ITimeType timeType, long long int timePos, IDivTypeValue& divtype, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetAtrs(::std::string codeId, ITimeType timeType, IQuery query, IAtrValues& avgAtrs, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAtrs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetOneAtr.
     */
    struct GetOneAtrResult
    {
        bool returnValue;
        IAtrValue avgAtr;
    };

    virtual bool GetOneAtr(::std::string codeId, ITimeType timeType, long long int timePos, IAtrValue& avgAtr, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace IBTrader
{

class IQDatabasePrx : public virtual ::Ice::Proxy<IQDatabasePrx, ::Ice::ObjectPrx>
{
public:

    int IdlCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &IQDatabasePrx::_iceI_IdlCount, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto IdlCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &IQDatabasePrx::_iceI_IdlCount, context);
    }

    ::std::function<void()>
    IdlCountAsync(::std::function<void(int)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_IdlCount, context);
    }

    /// \cond INTERNAL
    void _iceI_IdlCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    bool IsAllIdle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &IQDatabasePrx::_iceI_IsAllIdle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto IsAllIdleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &IQDatabasePrx::_iceI_IsAllIdle, context);
    }

    ::std::function<void()>
    IsAllIdleAsync(::std::function<void(bool)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_IsAllIdle, context);
    }

    /// \cond INTERNAL
    void _iceI_IsAllIdle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    int TaskCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &IQDatabasePrx::_iceI_TaskCount, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto TaskCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &IQDatabasePrx::_iceI_TaskCount, context);
    }

    ::std::function<void()>
    TaskCountAsync(::std::function<void(int)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_TaskCount, context);
    }

    /// \cond INTERNAL
    void _iceI_TaskCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    void UpdateTickToDB(const ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateTickToDB, tick, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateTickToDBAsync(const ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateTickToDB, tick, context);
    }

    ::std::function<void()>
    UpdateTickToDBAsync(const ITick& tick,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateTickToDB, tick, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateTickToDB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ITick&, const ::Ice::Context&);
    /// \endcond

    ITick GetLastUpdateTick(int& updateCount, long long int& recentUpdateSecnd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetLastUpdateTickResult>(true, this, &IQDatabasePrx::_iceI_GetLastUpdateTick, context).get();
        updateCount = _result.updateCount;
        recentUpdateSecnd = _result.recentUpdateSecnd;
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto GetLastUpdateTickAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetLastUpdateTickResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetLastUpdateTickResult, P>(false, this, &IQDatabasePrx::_iceI_GetLastUpdateTick, context);
    }

    ::std::function<void()>
    GetLastUpdateTickAsync(::std::function<void(::IBTrader::ITick, int, long long int)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetLastUpdateTickResult&& _result)
        {
            response(::std::move(_result.returnValue), _result.updateCount, _result.recentUpdateSecnd);
        };
        return _makeLamdaOutgoing<IQDatabase::GetLastUpdateTickResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetLastUpdateTick, context);
    }

    /// \cond INTERNAL
    void _iceI_GetLastUpdateTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetLastUpdateTickResult>>&, const ::Ice::Context&);
    /// \endcond

    void DelCodeId(const ::std::string& codeId, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_DelCodeId, codeId, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto DelCodeIdAsync(const ::std::string& codeId, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_DelCodeId, codeId, beginTime, endTime, context);
    }

    ::std::function<void()>
    DelCodeIdAsync(const ::std::string& codeId, long long int beginTime, long long int endTime,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_DelCodeId, codeId, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_DelCodeId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllTicks, codeId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllTicksAsync(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllTicks, codeId, context);
    }

    ::std::function<void()>
    RemoveAllTicksAsync(const ::std::string& codeId,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllTicks, codeId, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void RemoveTicksByRange(const ::std::string& codeId, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveTicksByRange, codeId, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveTicksByRangeAsync(const ::std::string& codeId, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveTicksByRange, codeId, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveTicksByRangeAsync(const ::std::string& codeId, long long int beginTime, long long int endTime,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveTicksByRange, codeId, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveTicksByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void GetTicks(const ::std::string& codeId, const IQuery& query, ITicks& ticks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        ticks = _makePromiseOutgoing<::IBTrader::ITicks>(true, this, &IQDatabasePrx::_iceI_GetTicks, codeId, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetTicksAsync(const ::std::string& codeId, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::ITicks>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::ITicks, P>(false, this, &IQDatabasePrx::_iceI_GetTicks, codeId, query, context);
    }

    ::std::function<void()>
    GetTicksAsync(const ::std::string& codeId, const IQuery& query,
                  ::std::function<void(::IBTrader::ITicks)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::ITicks>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetTicks, codeId, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetTicks(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::ITicks>>&, const ::std::string&, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneTick(const ::std::string& codeId, long long int timePos, ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneTickResult>(true, this, &IQDatabasePrx::_iceI_GetOneTick, codeId, timePos, context).get();
        tick = ::std::move(_result.tick);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneTickAsync(const ::std::string& codeId, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneTickResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneTickResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneTick, codeId, timePos, context);
    }

    ::std::function<void()>
    GetOneTickAsync(const ::std::string& codeId, long long int timePos,
                    ::std::function<void(bool, ::IBTrader::ITick)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneTickResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.tick));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneTickResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneTick, codeId, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneTick(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneTickResult>>&, const ::std::string&, long long int, const ::Ice::Context&);
    /// \endcond

    void UpdateKLine(const ::std::string& codeId, ITimeType timeType, const IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateKLine, codeId, timeType, kline, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateKLineAsync(const ::std::string& codeId, ITimeType timeType, const IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateKLine, codeId, timeType, kline, context);
    }

    ::std::function<void()>
    UpdateKLineAsync(const ::std::string& codeId, ITimeType timeType, const IKLine& kline,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateKLine, codeId, timeType, kline, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IKLine&, const ::Ice::Context&);
    /// \endcond

    void UpdateKLines(const ::std::string& codeId, ITimeType timeType, const IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateKLines, codeId, timeType, klines, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateKLinesAsync(const ::std::string& codeId, ITimeType timeType, const IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateKLines, codeId, timeType, klines, context);
    }

    ::std::function<void()>
    UpdateKLinesAsync(const ::std::string& codeId, ITimeType timeType, const IKLines& klines,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateKLines, codeId, timeType, klines, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const IKLines&, const ::Ice::Context&);
    /// \endcond

    void RemoveAllKLines(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveAllKLines, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveAllKLinesAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveAllKLines, codeId, timeType, context);
    }

    ::std::function<void()>
    RemoveAllKLinesAsync(const ::std::string& codeId, ITimeType timeType,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveAllKLines, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveAllKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RemoveKLinesByRange(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveKLinesByRange, codeId, timeType, beginTime, endTime, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveKLinesByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveKLinesByRange, codeId, timeType, beginTime, endTime, context);
    }

    ::std::function<void()>
    RemoveKLinesByRangeAsync(const ::std::string& codeId, ITimeType timeType, long long int beginTime, long long int endTime,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveKLinesByRange, codeId, timeType, beginTime, endTime, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveKLinesByRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, long long int, const ::Ice::Context&);
    /// \endcond

    void RemoveOneKLine(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RemoveOneKLine, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RemoveOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RemoveOneKLine, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    RemoveOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RemoveOneKLine, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_RemoveOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetKLines(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        klines = _makePromiseOutgoing<::IBTrader::IKLines>(true, this, &IQDatabasePrx::_iceI_GetKLines, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKLinesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IKLines>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IKLines, P>(false, this, &IQDatabasePrx::_iceI_GetKLines, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetKLinesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                   ::std::function<void(::IBTrader::IKLines)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IKLines>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetKLines, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneKLine(const ::std::string& codeId, ITimeType timeType, long long int timePos, IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneKLineResult>(true, this, &IQDatabasePrx::_iceI_GetOneKLine, codeId, timeType, timePos, context).get();
        kline = ::std::move(_result.kline);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneKLineResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneKLineResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneKLine, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneKLineAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                     ::std::function<void(bool, ::IBTrader::IKLine)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneKLineResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.kline));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneKLineResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneKLine, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneKLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneKLineResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetKLinePairs(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query, IKLinePairs& kLinePairs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        kLinePairs = _makePromiseOutgoing<::IBTrader::IKLinePairs>(true, this, &IQDatabasePrx::_iceI_GetKLinePairs, first, second, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKLinePairsAsync(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IKLinePairs>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IKLinePairs, P>(false, this, &IQDatabasePrx::_iceI_GetKLinePairs, first, second, timeType, query, context);
    }

    ::std::function<void()>
    GetKLinePairsAsync(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query,
                       ::std::function<void(::IBTrader::IKLinePairs)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IKLinePairs>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetKLinePairs, first, second, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKLinePairs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLinePairs>>&, const ::std::string&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    void GetInvalidKLines(const ::std::string& codeId, ITimeType timeType, IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        klines = _makePromiseOutgoing<::IBTrader::IKLines>(true, this, &IQDatabasePrx::_iceI_GetInvalidKLines, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetInvalidKLinesAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IKLines>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IKLines, P>(false, this, &IQDatabasePrx::_iceI_GetInvalidKLines, codeId, timeType, context);
    }

    ::std::function<void()>
    GetInvalidKLinesAsync(const ::std::string& codeId, ITimeType timeType,
                          ::std::function<void(::IBTrader::IKLines)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IKLines>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetInvalidKLines, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_GetInvalidKLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IKLines>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void RecountAllIndex(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_RecountAllIndex, codeId, timeType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RecountAllIndexAsync(const ::std::string& codeId, ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_RecountAllIndex, codeId, timeType, context);
    }

    ::std::function<void()>
    RecountAllIndexAsync(const ::std::string& codeId, ITimeType timeType,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_RecountAllIndex, codeId, timeType, context);
    }

    /// \cond INTERNAL
    void _iceI_RecountAllIndex(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, const ::Ice::Context&);
    /// \endcond

    void UpdateAllIndexFromTimePos(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IQDatabasePrx::_iceI_UpdateAllIndexFromTimePos, codeId, timeType, timePos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateAllIndexFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IQDatabasePrx::_iceI_UpdateAllIndexFromTimePos, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    UpdateAllIndexFromTimePosAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_UpdateAllIndexFromTimePos, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateAllIndexFromTimePos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        mas = _makePromiseOutgoing<::IBTrader::IAvgValues>(true, this, &IQDatabasePrx::_iceI_GetMas, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAvgValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAvgValues, P>(false, this, &IQDatabasePrx::_iceI_GetMas, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                ::std::function<void(::IBTrader::IAvgValues)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAvgValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetMas, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneMa(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneMaResult>(true, this, &IQDatabasePrx::_iceI_GetOneMa, codeId, timeType, timePos, context).get();
        ma = ::std::move(_result.ma);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneMaResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneMaResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneMa, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                  ::std::function<void(bool, ::IBTrader::IAvgValue)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneMaResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ma));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneMaResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneMa, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMaResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetVwMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        mas = _makePromiseOutgoing<::IBTrader::IAvgValues>(true, this, &IQDatabasePrx::_iceI_GetVwMas, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetVwMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAvgValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAvgValues, P>(false, this, &IQDatabasePrx::_iceI_GetVwMas, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetVwMasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                  ::std::function<void(::IBTrader::IAvgValues)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAvgValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetVwMas, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetVwMas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneVwMa(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneVwMaResult>(true, this, &IQDatabasePrx::_iceI_GetOneVwMa, codeId, timeType, timePos, context).get();
        ma = ::std::move(_result.ma);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneVwMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneVwMaResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneVwMaResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneVwMa, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneVwMaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                    ::std::function<void(bool, ::IBTrader::IAvgValue)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneVwMaResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ma));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneVwMaResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneVwMa, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneVwMa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneVwMaResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetEmas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& emas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        emas = _makePromiseOutgoing<::IBTrader::IAvgValues>(true, this, &IQDatabasePrx::_iceI_GetEmas, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetEmasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAvgValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAvgValues, P>(false, this, &IQDatabasePrx::_iceI_GetEmas, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetEmasAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                 ::std::function<void(::IBTrader::IAvgValues)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAvgValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetEmas, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetEmas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAvgValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneEma(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneEmaResult>(true, this, &IQDatabasePrx::_iceI_GetOneEma, codeId, timeType, timePos, context).get();
        ema = ::std::move(_result.ema);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneEmaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneEmaResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneEmaResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneEma, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneEmaAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                   ::std::function<void(bool, ::IBTrader::IAvgValue)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneEmaResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ema));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneEmaResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneEma, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneEma(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneEmaResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetMacds(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IMacdValues& macds, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        macds = _makePromiseOutgoing<::IBTrader::IMacdValues>(true, this, &IQDatabasePrx::_iceI_GetMacds, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetMacdsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IMacdValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IMacdValues, P>(false, this, &IQDatabasePrx::_iceI_GetMacds, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetMacdsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                  ::std::function<void(::IBTrader::IMacdValues)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IMacdValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetMacds, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetMacds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IMacdValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneMacd(const ::std::string& codeId, ITimeType timeType, long long int timePos, IMacdValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneMacdResult>(true, this, &IQDatabasePrx::_iceI_GetOneMacd, codeId, timeType, timePos, context).get();
        ma = ::std::move(_result.ma);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneMacdAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneMacdResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneMacdResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneMacd, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneMacdAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                    ::std::function<void(bool, ::IBTrader::IMacdValue)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneMacdResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.ma));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneMacdResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneMacd, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneMacd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneMacdResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetDivTypes(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IDivTypeValues& divtypes, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        divtypes = _makePromiseOutgoing<::IBTrader::IDivTypeValues>(true, this, &IQDatabasePrx::_iceI_GetDivTypes, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetDivTypesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IDivTypeValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IDivTypeValues, P>(false, this, &IQDatabasePrx::_iceI_GetDivTypes, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetDivTypesAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                     ::std::function<void(::IBTrader::IDivTypeValues)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IDivTypeValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetDivTypes, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetDivTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IDivTypeValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneDivType(const ::std::string& codeId, ITimeType timeType, long long int timePos, IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneDivTypeResult>(true, this, &IQDatabasePrx::_iceI_GetOneDivType, codeId, timeType, timePos, context).get();
        divtype = ::std::move(_result.divtype);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneDivTypeAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneDivTypeResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneDivTypeResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneDivType, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneDivTypeAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                       ::std::function<void(bool, ::IBTrader::IDivTypeValue)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneDivTypeResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.divtype));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneDivTypeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneDivType, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneDivType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneDivTypeResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    void GetAtrs(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAtrValues& avgAtrs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        avgAtrs = _makePromiseOutgoing<::IBTrader::IAtrValues>(true, this, &IQDatabasePrx::_iceI_GetAtrs, codeId, timeType, query, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetAtrsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IBTrader::IAtrValues>>().get_future())
    {
        return _makePromiseOutgoing<::IBTrader::IAtrValues, P>(false, this, &IQDatabasePrx::_iceI_GetAtrs, codeId, timeType, query, context);
    }

    ::std::function<void()>
    GetAtrsAsync(const ::std::string& codeId, ITimeType timeType, const IQuery& query,
                 ::std::function<void(::IBTrader::IAtrValues)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::IBTrader::IAtrValues>(std::move(response), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetAtrs, codeId, timeType, query, context);
    }

    /// \cond INTERNAL
    void _iceI_GetAtrs(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IBTrader::IAtrValues>>&, const ::std::string&, ITimeType, const IQuery&, const ::Ice::Context&);
    /// \endcond

    bool GetOneAtr(const ::std::string& codeId, ITimeType timeType, long long int timePos, IAtrValue& avgAtr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<IQDatabase::GetOneAtrResult>(true, this, &IQDatabasePrx::_iceI_GetOneAtr, codeId, timeType, timePos, context).get();
        avgAtr = ::std::move(_result.avgAtr);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetOneAtrAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<IQDatabase::GetOneAtrResult>>().get_future())
    {
        return _makePromiseOutgoing<IQDatabase::GetOneAtrResult, P>(false, this, &IQDatabasePrx::_iceI_GetOneAtr, codeId, timeType, timePos, context);
    }

    ::std::function<void()>
    GetOneAtrAsync(const ::std::string& codeId, ITimeType timeType, long long int timePos,
                   ::std::function<void(bool, ::IBTrader::IAtrValue)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](IQDatabase::GetOneAtrResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.avgAtr));
        };
        return _makeLamdaOutgoing<IQDatabase::GetOneAtrResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IBTrader::IQDatabasePrx::_iceI_GetOneAtr, codeId, timeType, timePos, context);
    }

    /// \cond INTERNAL
    void _iceI_GetOneAtr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IQDatabase::GetOneAtrResult>>&, const ::std::string&, ITimeType, long long int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IQDatabasePrx() = default;
    friend ::std::shared_ptr<IQDatabasePrx> IceInternal::createProxy<IQDatabasePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond INTERNAL
namespace IBTrader
{

using IQDatabasePtr = ::std::shared_ptr<IQDatabase>;
using IQDatabasePrxPtr = ::std::shared_ptr<IQDatabasePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace IBTrader
{

class IQDatabase;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< IQDatabase>&);
::IceProxy::Ice::Object* upCast(IQDatabase*);
/// \endcond

}

}

namespace IBTrader
{

class IQDatabase;
/// \cond INTERNAL
::Ice::Object* upCast(IQDatabase*);
/// \endcond
typedef ::IceInternal::Handle< IQDatabase> IQDatabasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IBTrader::IQDatabase> IQDatabasePrx;
typedef IQDatabasePrx IQDatabasePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IQDatabasePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace IBTrader
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_IdlCount.
 */
class Callback_IQDatabase_IdlCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_IdlCount_Base> Callback_IQDatabase_IdlCountPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_IsAllIdle.
 */
class Callback_IQDatabase_IsAllIdle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_IsAllIdle_Base> Callback_IQDatabase_IsAllIdlePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_TaskCount.
 */
class Callback_IQDatabase_TaskCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_TaskCount_Base> Callback_IQDatabase_TaskCountPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateTickToDB.
 */
class Callback_IQDatabase_UpdateTickToDB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateTickToDB_Base> Callback_IQDatabase_UpdateTickToDBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetLastUpdateTick.
 */
class Callback_IQDatabase_GetLastUpdateTick_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetLastUpdateTick_Base> Callback_IQDatabase_GetLastUpdateTickPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_DelCodeId.
 */
class Callback_IQDatabase_DelCodeId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_DelCodeId_Base> Callback_IQDatabase_DelCodeIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllTicks.
 */
class Callback_IQDatabase_RemoveAllTicks_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllTicks_Base> Callback_IQDatabase_RemoveAllTicksPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveTicksByRange.
 */
class Callback_IQDatabase_RemoveTicksByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveTicksByRange_Base> Callback_IQDatabase_RemoveTicksByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetTicks.
 */
class Callback_IQDatabase_GetTicks_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetTicks_Base> Callback_IQDatabase_GetTicksPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneTick.
 */
class Callback_IQDatabase_GetOneTick_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneTick_Base> Callback_IQDatabase_GetOneTickPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLine.
 */
class Callback_IQDatabase_UpdateKLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateKLine_Base> Callback_IQDatabase_UpdateKLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLines.
 */
class Callback_IQDatabase_UpdateKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateKLines_Base> Callback_IQDatabase_UpdateKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllKLines.
 */
class Callback_IQDatabase_RemoveAllKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveAllKLines_Base> Callback_IQDatabase_RemoveAllKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveKLinesByRange.
 */
class Callback_IQDatabase_RemoveKLinesByRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveKLinesByRange_Base> Callback_IQDatabase_RemoveKLinesByRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveOneKLine.
 */
class Callback_IQDatabase_RemoveOneKLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RemoveOneKLine_Base> Callback_IQDatabase_RemoveOneKLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLines.
 */
class Callback_IQDatabase_GetKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetKLines_Base> Callback_IQDatabase_GetKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneKLine.
 */
class Callback_IQDatabase_GetOneKLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneKLine_Base> Callback_IQDatabase_GetOneKLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLinePairs.
 */
class Callback_IQDatabase_GetKLinePairs_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetKLinePairs_Base> Callback_IQDatabase_GetKLinePairsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetInvalidKLines.
 */
class Callback_IQDatabase_GetInvalidKLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetInvalidKLines_Base> Callback_IQDatabase_GetInvalidKLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAllIndex.
 */
class Callback_IQDatabase_RecountAllIndex_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_RecountAllIndex_Base> Callback_IQDatabase_RecountAllIndexPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateAllIndexFromTimePos.
 */
class Callback_IQDatabase_UpdateAllIndexFromTimePos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_UpdateAllIndexFromTimePos_Base> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMas.
 */
class Callback_IQDatabase_GetMas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetMas_Base> Callback_IQDatabase_GetMasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMa.
 */
class Callback_IQDatabase_GetOneMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneMa_Base> Callback_IQDatabase_GetOneMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetVwMas.
 */
class Callback_IQDatabase_GetVwMas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetVwMas_Base> Callback_IQDatabase_GetVwMasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneVwMa.
 */
class Callback_IQDatabase_GetOneVwMa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneVwMa_Base> Callback_IQDatabase_GetOneVwMaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetEmas.
 */
class Callback_IQDatabase_GetEmas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetEmas_Base> Callback_IQDatabase_GetEmasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneEma.
 */
class Callback_IQDatabase_GetOneEma_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneEma_Base> Callback_IQDatabase_GetOneEmaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMacds.
 */
class Callback_IQDatabase_GetMacds_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetMacds_Base> Callback_IQDatabase_GetMacdsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMacd.
 */
class Callback_IQDatabase_GetOneMacd_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneMacd_Base> Callback_IQDatabase_GetOneMacdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetDivTypes.
 */
class Callback_IQDatabase_GetDivTypes_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetDivTypes_Base> Callback_IQDatabase_GetDivTypesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneDivType.
 */
class Callback_IQDatabase_GetOneDivType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneDivType_Base> Callback_IQDatabase_GetOneDivTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetAtrs.
 */
class Callback_IQDatabase_GetAtrs_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetAtrs_Base> Callback_IQDatabase_GetAtrsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneAtr.
 */
class Callback_IQDatabase_GetOneAtr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IQDatabase_GetOneAtr_Base> Callback_IQDatabase_GetOneAtrPtr;

}

namespace IceProxy
{

namespace IBTrader
{

class IQDatabase : public virtual ::Ice::Proxy<IQDatabase, ::IceProxy::Ice::Object>
{
public:

    ::Ice::Int IdlCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_IdlCount(_iceI_begin_IdlCount(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_IdlCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_IdlCount(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_IdlCount(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IdlCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IdlCount(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IdlCount(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IdlCount(const ::IBTrader::Callback_IQDatabase_IdlCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IdlCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IdlCount(const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_IdlCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IdlCount(context, cb, cookie);
    }

    ::Ice::Int end_IdlCount(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_IdlCount(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool IsAllIdle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_IsAllIdle(_iceI_begin_IsAllIdle(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_IsAllIdle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_IsAllIdle(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_IsAllIdle(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAllIdle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsAllIdle(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAllIdle(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsAllIdle(const ::IBTrader::Callback_IQDatabase_IsAllIdlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAllIdle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsAllIdle(const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_IsAllIdlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAllIdle(context, cb, cookie);
    }

    bool end_IsAllIdle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_IsAllIdle(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int TaskCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_TaskCount(_iceI_begin_TaskCount(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_TaskCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_TaskCount(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TaskCount(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TaskCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TaskCount(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TaskCount(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TaskCount(const ::IBTrader::Callback_IQDatabase_TaskCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TaskCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TaskCount(const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_TaskCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TaskCount(context, cb, cookie);
    }

    ::Ice::Int end_TaskCount(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_TaskCount(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateTickToDB(_iceI_begin_UpdateTickToDB(tick, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateTickToDB(tick, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::IBTrader::Callback_IQDatabase_UpdateTickToDBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTickToDB(const ::IBTrader::ITick& tick, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateTickToDBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTickToDB(tick, context, cb, cookie);
    }

    void end_UpdateTickToDB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateTickToDB(const ::IBTrader::ITick&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::IBTrader::ITick GetLastUpdateTick(::Ice::Int& updateCount, ::Ice::Long& recentUpdateSecnd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetLastUpdateTick(updateCount, recentUpdateSecnd, _iceI_begin_GetLastUpdateTick(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetLastUpdateTick(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::IBTrader::Callback_IQDatabase_GetLastUpdateTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLastUpdateTick(const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetLastUpdateTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLastUpdateTick(context, cb, cookie);
    }

    ::IBTrader::ITick end_GetLastUpdateTick(::Ice::Int& updateCount, ::Ice::Long& recentUpdateSecnd, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetLastUpdateTick(::Ice::Int& iceP_updateCount, ::Ice::Long& iceP_recentUpdateSecnd, ::IBTrader::ITick& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetLastUpdateTick(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_DelCodeId(_iceI_begin_DelCodeId(codeId, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_DelCodeId(codeId, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DelCodeId(codeId, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DelCodeId(codeId, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_DelCodeIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DelCodeId(codeId, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_DelCodeIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DelCodeId(codeId, beginTime, endTime, context, cb, cookie);
    }

    void end_DelCodeId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_DelCodeId(const ::std::string&, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllTicks(_iceI_begin_RemoveAllTicks(codeId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllTicks(codeId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::IBTrader::Callback_IQDatabase_RemoveAllTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllTicks(const ::std::string& codeId, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllTicks(codeId, context, cb, cookie);
    }

    void end_RemoveAllTicks(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllTicks(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveTicksByRange(_iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveTicksByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveTicksByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveTicksByRange(codeId, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveTicksByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveTicksByRange(const ::std::string&, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, ::IBTrader::ITicks& ticks, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetTicks(ticks, _iceI_begin_GetTicks(codeId, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetTicks(codeId, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetTicks(const ::std::string& codeId, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetTicksPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetTicks(codeId, query, context, cb, cookie);
    }

    void end_GetTicks(::IBTrader::ITicks& ticks, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetTicks(::IBTrader::ITicks& iceP_ticks, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetTicks(const ::std::string&, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, ::IBTrader::ITick& tick, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneTick(tick, _iceI_begin_GetOneTick(codeId, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneTickPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneTick(codeId, timePos, context, cb, cookie);
    }

    bool end_GetOneTick(::IBTrader::ITick& tick, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneTick(::IBTrader::ITick& iceP_tick, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneTick(const ::std::string&, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateKLine(_iceI_begin_UpdateKLine(codeId, timeType, kline, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::IBTrader::Callback_IQDatabase_UpdateKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLine& kline, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLine(codeId, timeType, kline, context, cb, cookie);
    }

    void end_UpdateKLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateKLine(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IKLine&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateKLines(_iceI_begin_UpdateKLines(codeId, timeType, klines, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateKLines(codeId, timeType, klines, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLines& klines, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLines(codeId, timeType, klines, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLines& klines, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLines(codeId, timeType, klines, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLines& klines, const ::IBTrader::Callback_IQDatabase_UpdateKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLines(codeId, timeType, klines, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IKLines& klines, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateKLines(codeId, timeType, klines, context, cb, cookie);
    }

    void end_UpdateKLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateKLines(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IKLines&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveAllKLines(_iceI_begin_RemoveAllKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RemoveAllKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveAllKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveAllKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveAllKLines(codeId, timeType, context, cb, cookie);
    }

    void end_RemoveAllKLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveAllKLines(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveKLinesByRange(_iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::IBTrader::Callback_IQDatabase_RemoveKLinesByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveKLinesByRange(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveKLinesByRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveKLinesByRange(codeId, timeType, beginTime, endTime, context, cb, cookie);
    }

    void end_RemoveKLinesByRange(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveKLinesByRange(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RemoveOneKLine(_iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_RemoveOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RemoveOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RemoveOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RemoveOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_RemoveOneKLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RemoveOneKLine(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetKLines(klines, _iceI_begin_GetKLines(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLines(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetKLines(::IBTrader::IKLines& klines, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKLines(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IKLine& kline, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneKLine(kline, _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneKLine(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneKLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneKLine(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneKLine(::IBTrader::IKLine& kline, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneKLine(::IBTrader::IKLine& iceP_kline, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneKLine(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IKLinePairs& kLinePairs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetKLinePairs(kLinePairs, _iceI_begin_GetKLinePairs(first, second, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetKLinePairsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKLinePairs(const ::std::string& first, const ::std::string& second, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetKLinePairsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKLinePairs(first, second, timeType, query, context, cb, cookie);
    }

    void end_GetKLinePairs(::IBTrader::IKLinePairs& kLinePairs, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetKLinePairs(::IBTrader::IKLinePairs& iceP_kLinePairs, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKLinePairs(const ::std::string&, const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::IBTrader::IKLines& klines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetInvalidKLines(klines, _iceI_begin_GetInvalidKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_GetInvalidKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetInvalidKLines(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetInvalidKLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetInvalidKLines(codeId, timeType, context, cb, cookie);
    }

    void end_GetInvalidKLines(::IBTrader::IKLines& klines, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetInvalidKLines(::IBTrader::IKLines& iceP_klines, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetInvalidKLines(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RecountAllIndex(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RecountAllIndex(_iceI_begin_RecountAllIndex(codeId, timeType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RecountAllIndex(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RecountAllIndex(codeId, timeType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RecountAllIndex(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAllIndex(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAllIndex(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAllIndex(codeId, timeType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAllIndex(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::Callback_IQDatabase_RecountAllIndexPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAllIndex(codeId, timeType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RecountAllIndex(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_RecountAllIndexPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RecountAllIndex(codeId, timeType, context, cb, cookie);
    }

    void end_RecountAllIndex(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RecountAllIndex(const ::std::string&, ::IBTrader::ITimeType, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateAllIndexFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateAllIndexFromTimePos(_iceI_begin_UpdateAllIndexFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateAllIndexFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateAllIndexFromTimePos(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateAllIndexFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAllIndexFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateAllIndexFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAllIndexFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateAllIndexFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_UpdateAllIndexFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAllIndexFromTimePos(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateAllIndexFromTimePos(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_UpdateAllIndexFromTimePosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateAllIndexFromTimePos(codeId, timeType, timePos, context, cb, cookie);
    }

    void end_UpdateAllIndexFromTimePos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateAllIndexFromTimePos(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetMas(mas, _iceI_begin_GetMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMas(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetMas(::IBTrader::IAvgValues& mas, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetMas(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneMa(ma, _iceI_begin_GetOneMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMa(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneMa(::IBTrader::IAvgValue& ma, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneMa(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAvgValues& mas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetVwMas(mas, _iceI_begin_GetVwMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetVwMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVwMas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetVwMasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVwMas(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetVwMas(::IBTrader::IAvgValues& mas, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetVwMas(::IBTrader::IAvgValues& iceP_mas, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetVwMas(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAvgValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneVwMa(ma, _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneVwMa(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneVwMaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneVwMa(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneVwMa(::IBTrader::IAvgValue& ma, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneVwMa(::IBTrader::IAvgValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneVwMa(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAvgValues& emas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetEmas(emas, _iceI_begin_GetEmas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetEmasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetEmas(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetEmasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetEmas(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetEmas(::IBTrader::IAvgValues& emas, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetEmas(::IBTrader::IAvgValues& iceP_emas, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetEmas(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAvgValue& ema, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneEma(ema, _iceI_begin_GetOneEma(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneEma(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneEmaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneEma(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneEma(::IBTrader::IAvgValue& ema, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneEma(::IBTrader::IAvgValue& iceP_ema, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneEma(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IMacdValues& macds, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetMacds(macds, _iceI_begin_GetMacds(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetMacdsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetMacds(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetMacdsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetMacds(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetMacds(::IBTrader::IMacdValues& macds, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetMacds(::IBTrader::IMacdValues& iceP_macds, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetMacds(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IMacdValue& ma, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneMacd(ma, _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneMacd(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneMacdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneMacd(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneMacd(::IBTrader::IMacdValue& ma, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneMacd(::IBTrader::IMacdValue& iceP_ma, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneMacd(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IDivTypeValues& divtypes, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetDivTypes(divtypes, _iceI_begin_GetDivTypes(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetDivTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDivTypes(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetDivTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetDivTypes(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetDivTypes(::IBTrader::IDivTypeValues& divtypes, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetDivTypes(::IBTrader::IDivTypeValues& iceP_divtypes, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetDivTypes(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IDivTypeValue& divtype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneDivType(divtype, _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneDivType(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneDivTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneDivType(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneDivType(::IBTrader::IDivTypeValue& divtype, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneDivType(::IBTrader::IDivTypeValue& iceP_divtype, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneDivType(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, ::IBTrader::IAtrValues& avgAtrs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetAtrs(avgAtrs, _iceI_begin_GetAtrs(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::IBTrader::Callback_IQDatabase_GetAtrsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAtrs(const ::std::string& codeId, ::IBTrader::ITimeType timeType, const ::IBTrader::IQuery& query, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetAtrsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAtrs(codeId, timeType, query, context, cb, cookie);
    }

    void end_GetAtrs(::IBTrader::IAtrValues& avgAtrs, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetAtrs(::IBTrader::IAtrValues& iceP_avgAtrs, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetAtrs(const ::std::string&, ::IBTrader::ITimeType, const ::IBTrader::IQuery&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, ::IBTrader::IAtrValue& avgAtr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetOneAtr(avgAtr, _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::IBTrader::Callback_IQDatabase_GetOneAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetOneAtr(const ::std::string& codeId, ::IBTrader::ITimeType timeType, ::Ice::Long timePos, const ::Ice::Context& context, const ::IBTrader::Callback_IQDatabase_GetOneAtrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetOneAtr(codeId, timeType, timePos, context, cb, cookie);
    }

    bool end_GetOneAtr(::IBTrader::IAtrValue& avgAtr, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetOneAtr(::IBTrader::IAtrValue& iceP_avgAtr, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetOneAtr(const ::std::string&, ::IBTrader::ITimeType, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace IBTrader
{

class IQDatabase : public virtual ::Ice::Object
{
public:

    typedef IQDatabasePrx ProxyType;
    typedef IQDatabasePtr PointerType;

    virtual ~IQDatabase();

#ifdef ICE_CPP11_COMPILER
    IQDatabase() = default;
    IQDatabase(const IQDatabase&) = default;
    IQDatabase& operator=(const IQDatabase&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int IdlCount(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_IdlCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool IsAllIdle(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_IsAllIdle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int TaskCount(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_TaskCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateTickToDB(const ITick& tick, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTickToDB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ITick GetLastUpdateTick(::Ice::Int& updateCount, ::Ice::Long& recentUpdateSecnd, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLastUpdateTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DelCodeId(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_DelCodeId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllTicks(const ::std::string& codeId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveTicksByRange(const ::std::string& codeId, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveTicksByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetTicks(const ::std::string& codeId, const IQuery& query, ITicks& ticks, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetTicks(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneTick(const ::std::string& codeId, ::Ice::Long timePos, ITick& tick, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneTick(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateKLine(const ::std::string& codeId, ITimeType timeType, const IKLine& kline, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateKLines(const ::std::string& codeId, ITimeType timeType, const IKLines& klines, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveAllKLines(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveAllKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveKLinesByRange(const ::std::string& codeId, ITimeType timeType, ::Ice::Long beginTime, ::Ice::Long endTime, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveKLinesByRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RemoveOneKLine(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RemoveOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLines(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IKLines& klines, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneKLine(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IKLine& kline, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneKLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetKLinePairs(const ::std::string& first, const ::std::string& second, ITimeType timeType, const IQuery& query, IKLinePairs& kLinePairs, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKLinePairs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetInvalidKLines(const ::std::string& codeId, ITimeType timeType, IKLines& klines, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetInvalidKLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RecountAllIndex(const ::std::string& codeId, ITimeType timeType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RecountAllIndex(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateAllIndexFromTimePos(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateAllIndexFromTimePos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneMa(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAvgValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetVwMas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& mas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVwMas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneVwMa(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAvgValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneVwMa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetEmas(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAvgValues& emas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetEmas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneEma(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAvgValue& ema, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneEma(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetMacds(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IMacdValues& macds, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetMacds(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneMacd(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IMacdValue& ma, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneMacd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetDivTypes(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IDivTypeValues& divtypes, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetDivTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneDivType(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IDivTypeValue& divtype, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneDivType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetAtrs(const ::std::string& codeId, ITimeType timeType, const IQuery& query, IAtrValues& avgAtrs, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAtrs(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetOneAtr(const ::std::string& codeId, ITimeType timeType, ::Ice::Long timePos, IAtrValue& avgAtr, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetOneAtr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const IQDatabase& lhs, const IQDatabase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IQDatabase& lhs, const IQDatabase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

namespace IBTrader
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_IdlCount.
 */
template<class T>
class CallbackNC_IQDatabase_IdlCount : public Callback_IQDatabase_IdlCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_IQDatabase_IdlCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_IdlCount(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 */
template<class T> Callback_IQDatabase_IdlCountPtr
newCallback_IQDatabase_IdlCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_IdlCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 */
template<class T> Callback_IQDatabase_IdlCountPtr
newCallback_IQDatabase_IdlCount(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_IdlCount<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_IdlCount.
 */
template<class T, typename CT>
class Callback_IQDatabase_IdlCount : public Callback_IQDatabase_IdlCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_IQDatabase_IdlCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_IdlCount(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 */
template<class T, typename CT> Callback_IQDatabase_IdlCountPtr
newCallback_IQDatabase_IdlCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_IdlCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IdlCount.
 */
template<class T, typename CT> Callback_IQDatabase_IdlCountPtr
newCallback_IQDatabase_IdlCount(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_IdlCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_IsAllIdle.
 */
template<class T>
class CallbackNC_IQDatabase_IsAllIdle : public Callback_IQDatabase_IsAllIdle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_IQDatabase_IsAllIdle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsAllIdle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 */
template<class T> Callback_IQDatabase_IsAllIdlePtr
newCallback_IQDatabase_IsAllIdle(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_IsAllIdle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 */
template<class T> Callback_IQDatabase_IsAllIdlePtr
newCallback_IQDatabase_IsAllIdle(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_IsAllIdle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_IsAllIdle.
 */
template<class T, typename CT>
class Callback_IQDatabase_IsAllIdle : public Callback_IQDatabase_IsAllIdle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_IQDatabase_IsAllIdle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsAllIdle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 */
template<class T, typename CT> Callback_IQDatabase_IsAllIdlePtr
newCallback_IQDatabase_IsAllIdle(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_IsAllIdle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_IsAllIdle.
 */
template<class T, typename CT> Callback_IQDatabase_IsAllIdlePtr
newCallback_IQDatabase_IsAllIdle(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_IsAllIdle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_TaskCount.
 */
template<class T>
class CallbackNC_IQDatabase_TaskCount : public Callback_IQDatabase_TaskCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_IQDatabase_TaskCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_TaskCount(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 */
template<class T> Callback_IQDatabase_TaskCountPtr
newCallback_IQDatabase_TaskCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_TaskCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 */
template<class T> Callback_IQDatabase_TaskCountPtr
newCallback_IQDatabase_TaskCount(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_TaskCount<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_TaskCount.
 */
template<class T, typename CT>
class Callback_IQDatabase_TaskCount : public Callback_IQDatabase_TaskCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_IQDatabase_TaskCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_TaskCount(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 */
template<class T, typename CT> Callback_IQDatabase_TaskCountPtr
newCallback_IQDatabase_TaskCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_TaskCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_TaskCount.
 */
template<class T, typename CT> Callback_IQDatabase_TaskCountPtr
newCallback_IQDatabase_TaskCount(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_TaskCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateTickToDB.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateTickToDB : public Callback_IQDatabase_UpdateTickToDB_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateTickToDB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateTickToDB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateTickToDB.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateTickToDB : public Callback_IQDatabase_UpdateTickToDB_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateTickToDB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateTickToDB.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateTickToDBPtr
newCallback_IQDatabase_UpdateTickToDB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateTickToDB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetLastUpdateTick.
 */
template<class T>
class CallbackNC_IQDatabase_GetLastUpdateTick : public Callback_IQDatabase_GetLastUpdateTick_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ITick&, ::Ice::Int, ::Ice::Long);

    CallbackNC_IQDatabase_GetLastUpdateTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_updateCount;
        ::Ice::Long iceP_recentUpdateSecnd;
        ITick ret;
        try
        {
            ret = proxy->end_GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_updateCount, iceP_recentUpdateSecnd);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetLastUpdateTick<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(T* instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetLastUpdateTick<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetLastUpdateTick.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetLastUpdateTick : public Callback_IQDatabase_GetLastUpdateTick_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ITick&, ::Ice::Int, ::Ice::Long, const CT&);

    Callback_IQDatabase_GetLastUpdateTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_updateCount;
        ::Ice::Long iceP_recentUpdateSecnd;
        ITick ret;
        try
        {
            ret = proxy->end_GetLastUpdateTick(iceP_updateCount, iceP_recentUpdateSecnd, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_updateCount, iceP_recentUpdateSecnd, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetLastUpdateTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetLastUpdateTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetLastUpdateTickPtr
newCallback_IQDatabase_GetLastUpdateTick(T* instance, void (T::*cb)(const ITick&, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetLastUpdateTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_DelCodeId.
 */
template<class T>
class CallbackNC_IQDatabase_DelCodeId : public Callback_IQDatabase_DelCodeId_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_DelCodeId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_DelCodeId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_DelCodeId<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_DelCodeId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_DelCodeId<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_DelCodeId.
 */
template<class T, typename CT>
class Callback_IQDatabase_DelCodeId : public Callback_IQDatabase_DelCodeId_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_DelCodeId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T, typename CT> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_DelCodeId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T, typename CT> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_DelCodeId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T, typename CT> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_DelCodeId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_DelCodeId.
 */
template<class T, typename CT> Callback_IQDatabase_DelCodeIdPtr
newCallback_IQDatabase_DelCodeId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_DelCodeId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllTicks.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllTicks : public Callback_IQDatabase_RemoveAllTicks_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllTicks<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllTicks.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllTicks : public Callback_IQDatabase_RemoveAllTicks_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllTicks.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllTicksPtr
newCallback_IQDatabase_RemoveAllTicks(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllTicks<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveTicksByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveTicksByRange : public Callback_IQDatabase_RemoveTicksByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveTicksByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveTicksByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveTicksByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveTicksByRange : public Callback_IQDatabase_RemoveTicksByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveTicksByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveTicksByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveTicksByRangePtr
newCallback_IQDatabase_RemoveTicksByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveTicksByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetTicks.
 */
template<class T>
class CallbackNC_IQDatabase_GetTicks : public Callback_IQDatabase_GetTicks_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ITicks&);

    CallbackNC_IQDatabase_GetTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITicks iceP_ticks;
        try
        {
            proxy->end_GetTicks(iceP_ticks, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_ticks);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITicks&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(T* instance, void (T::*cb)(const ITicks&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetTicks<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetTicks.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetTicks : public Callback_IQDatabase_GetTicks_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ITicks&, const CT&);

    Callback_IQDatabase_GetTicks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITicks iceP_ticks;
        try
        {
            proxy->end_GetTicks(iceP_ticks, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_ticks, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T, typename CT> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ITicks&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetTicks.
 */
template<class T, typename CT> Callback_IQDatabase_GetTicksPtr
newCallback_IQDatabase_GetTicks(T* instance, void (T::*cb)(const ITicks&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetTicks<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneTick.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneTick : public Callback_IQDatabase_GetOneTick_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ITick&);

    CallbackNC_IQDatabase_GetOneTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITick iceP_tick;
        bool ret;
        try
        {
            ret = proxy->end_GetOneTick(iceP_tick, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_tick);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ITick&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneTick<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(T* instance, void (T::*cb)(bool, const ITick&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneTick<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneTick.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneTick : public Callback_IQDatabase_GetOneTick_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ITick&, const CT&);

    Callback_IQDatabase_GetOneTick(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        ITick iceP_tick;
        bool ret;
        try
        {
            ret = proxy->end_GetOneTick(iceP_tick, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_tick, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ITick&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneTick.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneTickPtr
newCallback_IQDatabase_GetOneTick(T* instance, void (T::*cb)(bool, const ITick&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneTick<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLine.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateKLine : public Callback_IQDatabase_UpdateKLine_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLine.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateKLine : public Callback_IQDatabase_UpdateKLine_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLine.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinePtr
newCallback_IQDatabase_UpdateKLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLines.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateKLines : public Callback_IQDatabase_UpdateKLines_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLines<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateKLines<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateKLines : public Callback_IQDatabase_UpdateKLines_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateKLines.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateKLinesPtr
newCallback_IQDatabase_UpdateKLines(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateKLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllKLines.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveAllKLines : public Callback_IQDatabase_RemoveAllKLines_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveAllKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveAllKLines<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveAllKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveAllKLines : public Callback_IQDatabase_RemoveAllKLines_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveAllKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveAllKLines.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveAllKLinesPtr
newCallback_IQDatabase_RemoveAllKLines(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveAllKLines<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveKLinesByRange.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveKLinesByRange : public Callback_IQDatabase_RemoveKLinesByRange_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveKLinesByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveKLinesByRange<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveKLinesByRange.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveKLinesByRange : public Callback_IQDatabase_RemoveKLinesByRange_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveKLinesByRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveKLinesByRange.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveKLinesByRangePtr
newCallback_IQDatabase_RemoveKLinesByRange(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveKLinesByRange<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveOneKLine.
 */
template<class T>
class CallbackNC_IQDatabase_RemoveOneKLine : public Callback_IQDatabase_RemoveOneKLine_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RemoveOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RemoveOneKLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RemoveOneKLine.
 */
template<class T, typename CT>
class Callback_IQDatabase_RemoveOneKLine : public Callback_IQDatabase_RemoveOneKLine_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RemoveOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RemoveOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_RemoveOneKLinePtr
newCallback_IQDatabase_RemoveOneKLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RemoveOneKLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLines.
 */
template<class T>
class CallbackNC_IQDatabase_GetKLines : public Callback_IQDatabase_GetKLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IKLines&);

    CallbackNC_IQDatabase_GetKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_klines);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(T* instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetKLines : public Callback_IQDatabase_GetKLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IKLines&, const CT&);

    Callback_IQDatabase_GetKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_klines, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinesPtr
newCallback_IQDatabase_GetKLines(T* instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneKLine.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneKLine : public Callback_IQDatabase_GetOneKLine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IKLine&);

    CallbackNC_IQDatabase_GetOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLine iceP_kline;
        bool ret;
        try
        {
            ret = proxy->end_GetOneKLine(iceP_kline, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_kline);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IKLine&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(T* instance, void (T::*cb)(bool, const IKLine&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneKLine<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneKLine.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneKLine : public Callback_IQDatabase_GetOneKLine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IKLine&, const CT&);

    Callback_IQDatabase_GetOneKLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLine iceP_kline;
        bool ret;
        try
        {
            ret = proxy->end_GetOneKLine(iceP_kline, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_kline, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IKLine&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneKLine.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneKLinePtr
newCallback_IQDatabase_GetOneKLine(T* instance, void (T::*cb)(bool, const IKLine&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneKLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLinePairs.
 */
template<class T>
class CallbackNC_IQDatabase_GetKLinePairs : public Callback_IQDatabase_GetKLinePairs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IKLinePairs&);

    CallbackNC_IQDatabase_GetKLinePairs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLinePairs iceP_kLinePairs;
        try
        {
            proxy->end_GetKLinePairs(iceP_kLinePairs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_kLinePairs);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLinePairs&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLinePairs<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(T* instance, void (T::*cb)(const IKLinePairs&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetKLinePairs<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetKLinePairs.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetKLinePairs : public Callback_IQDatabase_GetKLinePairs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IKLinePairs&, const CT&);

    Callback_IQDatabase_GetKLinePairs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLinePairs iceP_kLinePairs;
        try
        {
            proxy->end_GetKLinePairs(iceP_kLinePairs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_kLinePairs, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLinePairs&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLinePairs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetKLinePairs.
 */
template<class T, typename CT> Callback_IQDatabase_GetKLinePairsPtr
newCallback_IQDatabase_GetKLinePairs(T* instance, void (T::*cb)(const IKLinePairs&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetKLinePairs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetInvalidKLines.
 */
template<class T>
class CallbackNC_IQDatabase_GetInvalidKLines : public Callback_IQDatabase_GetInvalidKLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IKLines&);

    CallbackNC_IQDatabase_GetInvalidKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetInvalidKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_klines);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetInvalidKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(T* instance, void (T::*cb)(const IKLines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetInvalidKLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetInvalidKLines.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetInvalidKLines : public Callback_IQDatabase_GetInvalidKLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IKLines&, const CT&);

    Callback_IQDatabase_GetInvalidKLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IKLines iceP_klines;
        try
        {
            proxy->end_GetInvalidKLines(iceP_klines, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_klines, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetInvalidKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetInvalidKLines.
 */
template<class T, typename CT> Callback_IQDatabase_GetInvalidKLinesPtr
newCallback_IQDatabase_GetInvalidKLines(T* instance, void (T::*cb)(const IKLines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetInvalidKLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAllIndex.
 */
template<class T>
class CallbackNC_IQDatabase_RecountAllIndex : public Callback_IQDatabase_RecountAllIndex_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_RecountAllIndex(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAllIndex<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAllIndex<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAllIndex<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_RecountAllIndex<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_RecountAllIndex.
 */
template<class T, typename CT>
class Callback_IQDatabase_RecountAllIndex : public Callback_IQDatabase_RecountAllIndex_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_RecountAllIndex(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAllIndex<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAllIndex<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAllIndex<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_RecountAllIndex.
 */
template<class T, typename CT> Callback_IQDatabase_RecountAllIndexPtr
newCallback_IQDatabase_RecountAllIndex(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_RecountAllIndex<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateAllIndexFromTimePos.
 */
template<class T>
class CallbackNC_IQDatabase_UpdateAllIndexFromTimePos : public Callback_IQDatabase_UpdateAllIndexFromTimePos_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IQDatabase_UpdateAllIndexFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAllIndexFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAllIndexFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAllIndexFromTimePos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_UpdateAllIndexFromTimePos<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_UpdateAllIndexFromTimePos.
 */
template<class T, typename CT>
class Callback_IQDatabase_UpdateAllIndexFromTimePos : public Callback_IQDatabase_UpdateAllIndexFromTimePos_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IQDatabase_UpdateAllIndexFromTimePos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAllIndexFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAllIndexFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAllIndexFromTimePos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_UpdateAllIndexFromTimePos.
 */
template<class T, typename CT> Callback_IQDatabase_UpdateAllIndexFromTimePosPtr
newCallback_IQDatabase_UpdateAllIndexFromTimePos(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_UpdateAllIndexFromTimePos<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMas.
 */
template<class T>
class CallbackNC_IQDatabase_GetMas : public Callback_IQDatabase_GetMas_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAvgValues&);

    CallbackNC_IQDatabase_GetMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_mas);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(T* instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMas<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMas.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetMas : public Callback_IQDatabase_GetMas_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAvgValues&, const CT&);

    Callback_IQDatabase_GetMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_mas, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetMasPtr
newCallback_IQDatabase_GetMas(T* instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMa.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneMa : public Callback_IQDatabase_GetOneMa_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAvgValue&);

    CallbackNC_IQDatabase_GetOneMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ma);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(T* instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMa<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneMa : public Callback_IQDatabase_GetOneMa_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAvgValue&, const CT&);

    Callback_IQDatabase_GetOneMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ma, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMaPtr
newCallback_IQDatabase_GetOneMa(T* instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetVwMas.
 */
template<class T>
class CallbackNC_IQDatabase_GetVwMas : public Callback_IQDatabase_GetVwMas_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAvgValues&);

    CallbackNC_IQDatabase_GetVwMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetVwMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_mas);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetVwMas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(T* instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetVwMas<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetVwMas.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetVwMas : public Callback_IQDatabase_GetVwMas_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAvgValues&, const CT&);

    Callback_IQDatabase_GetVwMas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_mas;
        try
        {
            proxy->end_GetVwMas(iceP_mas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_mas, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetVwMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetVwMas.
 */
template<class T, typename CT> Callback_IQDatabase_GetVwMasPtr
newCallback_IQDatabase_GetVwMas(T* instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetVwMas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneVwMa.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneVwMa : public Callback_IQDatabase_GetOneVwMa_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAvgValue&);

    CallbackNC_IQDatabase_GetOneVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneVwMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ma);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(T* instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneVwMa<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneVwMa.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneVwMa : public Callback_IQDatabase_GetOneVwMa_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAvgValue&, const CT&);

    Callback_IQDatabase_GetOneVwMa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneVwMa(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ma, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneVwMa.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneVwMaPtr
newCallback_IQDatabase_GetOneVwMa(T* instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneVwMa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetEmas.
 */
template<class T>
class CallbackNC_IQDatabase_GetEmas : public Callback_IQDatabase_GetEmas_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAvgValues&);

    CallbackNC_IQDatabase_GetEmas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_emas;
        try
        {
            proxy->end_GetEmas(iceP_emas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_emas);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetEmas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(T* instance, void (T::*cb)(const IAvgValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetEmas<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetEmas.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetEmas : public Callback_IQDatabase_GetEmas_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAvgValues&, const CT&);

    Callback_IQDatabase_GetEmas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValues iceP_emas;
        try
        {
            proxy->end_GetEmas(iceP_emas, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_emas, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T, typename CT> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetEmas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetEmas.
 */
template<class T, typename CT> Callback_IQDatabase_GetEmasPtr
newCallback_IQDatabase_GetEmas(T* instance, void (T::*cb)(const IAvgValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetEmas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneEma.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneEma : public Callback_IQDatabase_GetOneEma_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAvgValue&);

    CallbackNC_IQDatabase_GetOneEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ema;
        bool ret;
        try
        {
            ret = proxy->end_GetOneEma(iceP_ema, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ema);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneEma<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(T* instance, void (T::*cb)(bool, const IAvgValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneEma<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneEma.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneEma : public Callback_IQDatabase_GetOneEma_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAvgValue&, const CT&);

    Callback_IQDatabase_GetOneEma(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAvgValue iceP_ema;
        bool ret;
        try
        {
            ret = proxy->end_GetOneEma(iceP_ema, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ema, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneEma.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneEmaPtr
newCallback_IQDatabase_GetOneEma(T* instance, void (T::*cb)(bool, const IAvgValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneEma<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMacds.
 */
template<class T>
class CallbackNC_IQDatabase_GetMacds : public Callback_IQDatabase_GetMacds_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IMacdValues&);

    CallbackNC_IQDatabase_GetMacds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValues iceP_macds;
        try
        {
            proxy->end_GetMacds(iceP_macds, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_macds);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(const IceUtil::Handle<T>& instance, void (T::*cb)(const IMacdValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMacds<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(T* instance, void (T::*cb)(const IMacdValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetMacds<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetMacds.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetMacds : public Callback_IQDatabase_GetMacds_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IMacdValues&, const CT&);

    Callback_IQDatabase_GetMacds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValues iceP_macds;
        try
        {
            proxy->end_GetMacds(iceP_macds, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_macds, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T, typename CT> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(const IceUtil::Handle<T>& instance, void (T::*cb)(const IMacdValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMacds<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetMacds.
 */
template<class T, typename CT> Callback_IQDatabase_GetMacdsPtr
newCallback_IQDatabase_GetMacds(T* instance, void (T::*cb)(const IMacdValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetMacds<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMacd.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneMacd : public Callback_IQDatabase_GetOneMacd_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IMacdValue&);

    CallbackNC_IQDatabase_GetOneMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMacd(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_ma);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IMacdValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(T* instance, void (T::*cb)(bool, const IMacdValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneMacd<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneMacd.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneMacd : public Callback_IQDatabase_GetOneMacd_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IMacdValue&, const CT&);

    Callback_IQDatabase_GetOneMacd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IMacdValue iceP_ma;
        bool ret;
        try
        {
            ret = proxy->end_GetOneMacd(iceP_ma, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_ma, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IMacdValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneMacd.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneMacdPtr
newCallback_IQDatabase_GetOneMacd(T* instance, void (T::*cb)(bool, const IMacdValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneMacd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetDivTypes.
 */
template<class T>
class CallbackNC_IQDatabase_GetDivTypes : public Callback_IQDatabase_GetDivTypes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IDivTypeValues&);

    CallbackNC_IQDatabase_GetDivTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValues iceP_divtypes;
        try
        {
            proxy->end_GetDivTypes(iceP_divtypes, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_divtypes);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const IDivTypeValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetDivTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(T* instance, void (T::*cb)(const IDivTypeValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetDivTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetDivTypes.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetDivTypes : public Callback_IQDatabase_GetDivTypes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IDivTypeValues&, const CT&);

    Callback_IQDatabase_GetDivTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValues iceP_divtypes;
        try
        {
            proxy->end_GetDivTypes(iceP_divtypes, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_divtypes, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const IDivTypeValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetDivTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetDivTypes.
 */
template<class T, typename CT> Callback_IQDatabase_GetDivTypesPtr
newCallback_IQDatabase_GetDivTypes(T* instance, void (T::*cb)(const IDivTypeValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetDivTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneDivType.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneDivType : public Callback_IQDatabase_GetOneDivType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IDivTypeValue&);

    CallbackNC_IQDatabase_GetOneDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValue iceP_divtype;
        bool ret;
        try
        {
            ret = proxy->end_GetOneDivType(iceP_divtype, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_divtype);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IDivTypeValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(T* instance, void (T::*cb)(bool, const IDivTypeValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneDivType<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneDivType.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneDivType : public Callback_IQDatabase_GetOneDivType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IDivTypeValue&, const CT&);

    Callback_IQDatabase_GetOneDivType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IDivTypeValue iceP_divtype;
        bool ret;
        try
        {
            ret = proxy->end_GetOneDivType(iceP_divtype, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_divtype, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IDivTypeValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneDivType.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneDivTypePtr
newCallback_IQDatabase_GetOneDivType(T* instance, void (T::*cb)(bool, const IDivTypeValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneDivType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetAtrs.
 */
template<class T>
class CallbackNC_IQDatabase_GetAtrs : public Callback_IQDatabase_GetAtrs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IAtrValues&);

    CallbackNC_IQDatabase_GetAtrs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValues iceP_avgAtrs;
        try
        {
            proxy->end_GetAtrs(iceP_avgAtrs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_avgAtrs);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAtrValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetAtrs<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(T* instance, void (T::*cb)(const IAtrValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetAtrs<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetAtrs.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetAtrs : public Callback_IQDatabase_GetAtrs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IAtrValues&, const CT&);

    Callback_IQDatabase_GetAtrs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValues iceP_avgAtrs;
        try
        {
            proxy->end_GetAtrs(iceP_avgAtrs, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_avgAtrs, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(const IceUtil::Handle<T>& instance, void (T::*cb)(const IAtrValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetAtrs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetAtrs.
 */
template<class T, typename CT> Callback_IQDatabase_GetAtrsPtr
newCallback_IQDatabase_GetAtrs(T* instance, void (T::*cb)(const IAtrValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetAtrs<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneAtr.
 */
template<class T>
class CallbackNC_IQDatabase_GetOneAtr : public Callback_IQDatabase_GetOneAtr_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const IAtrValue&);

    CallbackNC_IQDatabase_GetOneAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValue iceP_avgAtr;
        bool ret;
        try
        {
            ret = proxy->end_GetOneAtr(iceP_avgAtr, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_avgAtr);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAtrValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(T* instance, void (T::*cb)(bool, const IAtrValue&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IQDatabase_GetOneAtr<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 * Create a wrapper instance by calling ::IBTrader::newCallback_IQDatabase_GetOneAtr.
 */
template<class T, typename CT>
class Callback_IQDatabase_GetOneAtr : public Callback_IQDatabase_GetOneAtr_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const IAtrValue&, const CT&);

    Callback_IQDatabase_GetOneAtr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IQDatabasePrx proxy = IQDatabasePrx::uncheckedCast(result->getProxy());
        IAtrValue iceP_avgAtr;
        bool ret;
        try
        {
            ret = proxy->end_GetOneAtr(iceP_avgAtr, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_avgAtr, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const IAtrValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneAtr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::IBTrader::IQDatabase::begin_GetOneAtr.
 */
template<class T, typename CT> Callback_IQDatabase_GetOneAtrPtr
newCallback_IQDatabase_GetOneAtr(T* instance, void (T::*cb)(bool, const IAtrValue&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IQDatabase_GetOneAtr<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
